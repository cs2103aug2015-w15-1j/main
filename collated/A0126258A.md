# A0126258A
###### src\main\java\backend\Logic\AddCommand.java
``` java
	private ArrayList<Task> generateTaskId() {

		ArrayList<Task> taskList = storageComponent.load();
		ArrayList<Task> newTaskList = new ArrayList<Task> ();
		int newTaskId = 0;

		for(Task task : taskList) {
			task.setTaskId(newTaskId);
			newTaskList.add(task);
			newTaskId++;
		}

		return newTaskList;
	}

```
###### src\main\java\backend\Logic\AddCommand.java
``` java
	private RecurrenceType getRecurrence(String recurrence) {

		if(recurrence.equals(RECURRING_DAY)) {
			return RecurrenceType.DAY;
		} else if(recurrence.equals(RECURRING_WEEK)) {
			return RecurrenceType.WEEK;
		} else if(recurrence.equals(RECURRING_MONTH)) {
			return RecurrenceType.MONTH;
		} else if(recurrence.equals(RECURRING_YEAR)) {
			return RecurrenceType.YEAR;
		}

		return RecurrenceType.NONE;
	}

```
###### src\main\java\backend\Logic\AddCommand.java
``` java
	private int stringToInteger(String string) {

		if (!string.isEmpty()) {
			return Integer.parseInt(string);
		} else {
			return -1;
		}
	}

```
###### src\main\java\backend\Logic\AddCommand.java
``` java
	private Task getTask(TaskType taskType, Command command) {
		
		RecurrenceType recurrenceType = getRecurrence("");
		int recurrenceFrequency = -1;
		if(!command.getRecurrence().equals("")) {
			String[] recurrence = command.getRecurrence().split(" ");
			recurrenceType = getRecurrence(recurrence[1]);
			recurrenceFrequency = stringToInteger(recurrence[0]);
		}
		int priority = stringToInteger(command.getPriority());
		String taskName = command.getTaskName();
		String taskDescription = command.getDescription();
		String startDate = command.getStartDateAndTime();
		String endDate = command.getEndDateAndTime();
		String reminderDate = command.getReminder();

		return new Task(taskType, recurrenceType, recurrenceFrequency, priority,  
				taskName, taskDescription, startDate, endDate, reminderDate);
	}

```
###### src\main\java\backend\Logic\AddCommand.java
``` java
	private String addTask(TaskType taskType, Command command) {

		Task newTask = getTask(taskType, command);

		taskList = generateTaskId();
		newTask.setTaskId(taskList.size());
		taskList.add(newTask);
		Collections.sort(taskList);
		storageComponent.save(taskList);

		return String.format(EXECUTION_ADD_TASK_SUCCESSFUL, newTask.getName());
	}
	
```
###### src\main\java\backend\Logic\Constant.java
``` java
package main.java.backend.Logic;

import java.text.SimpleDateFormat;
import java.util.Date;

public class Constant {
	
	private static final SimpleDateFormat standardFormat = 
			new SimpleDateFormat("EEE, dd MMM yy, hh:mma");
	private static final SimpleDateFormat standardFormatNoMinute = 
			new SimpleDateFormat("EEE, dd MMM yy, hha");
	
	private static final String COLON = ":";
	
	private Constant() {
		// Prevent Constant from being instantiated
	}
	
	public static long stringToMillisecond(String dateTime) {
		
		long dateTimeMillisecond;
		Date tempDateTime = new Date();
		
		try {
			if(dateTime.contains(COLON)) {
				tempDateTime = standardFormat.parse(dateTime);
			} else {
				tempDateTime = standardFormatNoMinute.parse(dateTime);
			}
			dateTimeMillisecond = tempDateTime.getTime();
		} catch (java.text.ParseException e) {
			dateTimeMillisecond = -1;
		}

		return dateTimeMillisecond;
	}
 }
```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private Task.RecurrenceType getRecurrenceType(String recurrenceType) {

		if(recurrenceType.equals(RECURRING_DAY)) {
			return Task.RecurrenceType.DAY;
		} if(recurrenceType.equals(RECURRING_WEEK)) {
			return Task.RecurrenceType.WEEK;
		} if(recurrenceType.equals(RECURRING_MONTH)) {
			return Task.RecurrenceType.MONTH;
		} if(recurrenceType.equals(RECURRING_YEAR)) {
			return Task.RecurrenceType.YEAR;
		} else {
			return Task.RecurrenceType.NONE;
		} 
	}
	
```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private boolean taskExist(Command command) {
		
		int taskIndex = -1;
		
		if(command.getTaskName().isEmpty()) {
			return true;
		} else {
			taskIndex = Integer.parseInt(this.getTaskName());
		}
		
		for(Task task : taskList) {
			if(taskIndex != -1 && task.getIndex() == taskIndex) {
				return true;
			}
		}
		
		return false;
	}
	
```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private void setTaskId(ArrayList<Task> taskList) {

		Collections.sort(taskList);

		int newTaskId = 0;

		for(Task task : taskList) {
			task.setTaskId(newTaskId);
			newTaskId++;
		}
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private Task.TaskType getTaskType(Task task) {

		if(!task.getEnd().isEmpty()) {
			return Task.TaskType.TODO;
		} else {
			return Task.TaskType.FLOATING;
		}
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private int getTaskId(int taskIndex) {

		int taskId = -1;
		for(Task task : taskList) {
			if(task.getIndex() == taskIndex) {
				taskId = task.getTaskId();
			}
		}

		return taskId;
	}
	

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private String setPriority(Command commandObject){
		
		try {
			int taskIndex = Integer.parseInt(commandObject.getTaskName());
			int priority = Integer.parseInt(commandObject.getPriority());
			int taskId = getTaskId(taskIndex);

			taskList.get(taskId).setPriority(priority);
			storageComponent.save(taskList);	

			return String.format(EXECUTION_SET_PRIORITY_SUCCESSFUL, taskIndex, priority);
		} catch (NumberFormatException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private String setUndone(Command commandObject) {
		
		try {
			int taskIndex = Integer.parseInt(commandObject.getTaskName());
			int taskId = getTaskId(taskIndex);

			taskList.get(taskId).setDone(false);
			storageComponent.save(taskList);

			return String.format(EXECUTION_DONE_COMMAND_SUCCESSFUL, taskIndex);
		} catch (NumberFormatException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private String setDone(Command commandObject) {
		
		try {
			int taskIndex = Integer.parseInt(commandObject.getTaskName());
			int taskId = getTaskId(taskIndex);

			taskList.get(taskId).setDone(true);
			taskList.get(taskId).setIndex(-1);
			storageComponent.save(taskList);

			return String.format(EXECUTION_UNDONE_COMMAND_SUCCESSFUL, taskIndex);
		} catch (NumberFormatException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private String setReminder(Command commandObject) {
		
		try {
			int taskIndex = Integer.parseInt(commandObject.getTaskName());
			String reminder = commandObject.getReminder();
			int taskId = getTaskId(taskIndex);
			
			taskList.get(taskId).setReminder(reminder);
			storageComponent.save(taskList);

			return String.format(EXECUTION_SET_REMINDER_SUCCESSFUL, taskIndex, reminder);
		} catch (NumberFormatException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private String setDescription(Command commandObject) {
		
		try {
			String description = commandObject.getDescription();
			int taskIndex = Integer.parseInt(commandObject.getTaskName());
			int taskId = getTaskId(taskIndex);
			
			taskList.get(taskId).setDescription(description);
			storageComponent.save(taskList);

			return String.format(EXECUTION_SET_DESCRIPTION_SUCCESSFUL, taskIndex);
		} catch (NumberFormatException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private String setEventStartAndEndTime(Command commandObject) {
		
		try {
			String start = commandObject.getStartDateAndTime();
			String end = commandObject.getEndDateAndTime();
			int eventIndex = Integer.parseInt(commandObject.getTaskName());
			int taskId = getTaskId(eventIndex);
			
			Task task = taskList.get(taskId);
			task.setTaskType(Task.TaskType.EVENT);
			task.setStart(start);
			task.setEnd(end);
			setTaskId(taskList);
			storageComponent.save(taskList);

			return String.format(EXECUTION_SET_EVENT_START_AND_END_TIME_SUCCESSFUL, 
					eventIndex, start, end);
		} catch (NumberFormatException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private String setDeadline(Command commandObject) {
		
		try {
			String end = commandObject.getEndDateAndTime();
			int taskIndex = Integer.parseInt(commandObject.getTaskName());
			int taskId = getTaskId(taskIndex);
			Task task = taskList.get(taskId);

			task.setStart(RESET);
			task.setEnd(end);
			task.setTaskType(getTaskType(task));
			setTaskId(taskList);
			storageComponent.save(taskList);

			return String.format(EXECUTION_SET_DEADLINE_SUCCESSFUL, taskIndex, end);
		} catch (NumberFormatException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private String setRecurring(Command commandObject) {
		
		try {
			String[] recurrence = commandObject.getRecurrence().split(" ");
			int recurrenceFrequency = Integer.parseInt(recurrence[0]);
			String recurrenceType = recurrence[1];
			int taskIndex = Integer.parseInt(commandObject.getTaskName());
			int taskId = getTaskId(taskIndex);
		
			Task task = taskList.get(taskId);
			
			if(!task.getTaskType().equals(TaskType.FLOATING)) {
				task.setRecurrenceFrequency(recurrenceFrequency);
				task.setRecurrenceType(getRecurrenceType(recurrenceType));
				setTaskId(taskList);
				storageComponent.save(taskList);
			} else {
				return EXECUTION_SET_RECURRING_UNSUCCESSFUL;
			}

			return String.format(EXECUTION_SET_RECURRING_SUCCESSFUL, taskIndex, 
					recurrenceFrequency + " " + recurrenceType);
		} catch (NumberFormatException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> generateTaskId(ArrayList<Task> taskList) {

		ArrayList<Task> newTaskList = new ArrayList<Task> ();
		int newTaskId = 0;

		for(Task task : taskList) {
			task.setTaskId(newTaskId);
			newTaskList.add(task);
			newTaskId++;
		}

		return newTaskList;
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private String reformatDate(String date) {
		
		String newDate = date
				.replace(TIME_MINUTES, RESET)
				.replace(TIME_AM_CAPS, TIME_AM)
				.replace(TIME_PM_CAPS, TIME_PM);
		
		return newDate;
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private void resetRecurring() {

		ArrayList<Task> taskList = storageComponent.load();
		ArrayList<Task> recurringTaskList = new ArrayList<Task> ();
		
		for(Task task : taskList) {

			Task nextTask = new Task(task);
			
			// Only reset date when todo/event is over
			if(!task.isRecurred() && !task.getRecurrenceType().equals(RecurrenceType.NONE)
					&& !nextTask.getTaskType().equals(TaskType.FLOATING)
					&& (task.getDone() || Constant.stringToMillisecond(task.getEnd()) 
					<= getCurrentTime())) {
				
				task.setRecurred(true);
				String nextDate = getUpcomingDate(nextTask, nextTask.getEnd());
				if(!(Constant.stringToMillisecond(nextDate) < 0)) {
					nextTask.setEnd(getUpcomingDate(nextTask, nextTask.getEnd()));
				}
				
				if(nextTask.getTaskType().equals(TaskType.EVENT)) {
					nextDate = getUpcomingDate(nextTask, nextTask.getStart());
					if(!(Constant.stringToMillisecond(nextDate) < 0)) {
						nextTask.setStart(getUpcomingDate(nextTask, nextTask.getStart()));
					}
				}
				
				recurringTaskList.add(nextTask);
			}
		}
		
		taskList.addAll(recurringTaskList);
		storageComponent.save(generateTaskId(taskList));
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private String getUpcomingDate(Task task, String currentDate) {
		
		String upcomingDate = new String();
		long currentDateMilliseconds = Constant.stringToMillisecond(currentDate);
		int factor = task.getRecurrenceFrequency();
		Calendar date = Calendar.getInstance();
        date.setTimeInMillis(currentDateMilliseconds);
		
		switch(task.getRecurrenceType()) {
			case NONE:
				break;
			case DAY:
				date.add(Calendar.DATE, factor);
	            upcomingDate = getDate(date.getTimeInMillis());
				break;
			case WEEK:
				factor *= 7;
				date.add(Calendar.DATE, factor);
	            upcomingDate = getDate(date.getTimeInMillis());
				break;
			case MONTH:
				date.add(Calendar.MONTH, factor);
	            upcomingDate = getDate(date.getTimeInMillis());
				break;
			case YEAR:
				date.add(Calendar.YEAR, factor);
	            upcomingDate = getDate(date.getTimeInMillis());
				break;
		}
		return reformatDate(upcomingDate);
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private String getDate(long milliSeconds) {
		Calendar calendar = Calendar.getInstance();
		calendar.setTimeInMillis(milliSeconds);
		return standardFormat.format(calendar.getTime());
	}

```
###### src\main\java\backend\Logic\Observer.java
``` java
	private long getCurrentTime() {

		long currentMilliseconds = System.currentTimeMillis();
		Date resultdate = new Date(currentMilliseconds);

		return Constant.stringToMillisecond(standardFormat.format(resultdate));
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private long getTodayStartTime() {

		LocalDateTime now = LocalDateTime.now();
		LocalDateTime midnight = now.toLocalDate().atStartOfDay();
		Date resultDate = Date.from(midnight
				.atZone(ZoneId.systemDefault()).toInstant());

		return Constant.stringToMillisecond(
				standardFormat.format(resultDate));
	}

```
###### src\main\java\backend\Logic\Observer.java
``` java
	private long getTodayEndTime() {

		return getTodayStartTime() + DAY_IN_MILLISECOND + DAY_IN_MILLISECOND;
	}

```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getUpcoming(ArrayList<Task> allTasks, TaskType taskType) {

		ArrayList<Task> upcomingTasks = new ArrayList<Task> ();

		for(Task task : allTasks) {
			if(taskType == TaskType.TODO && Constant.stringToMillisecond(task.getEnd()) 
					> getCurrentTime() && !task.getDone()) {
				upcomingTasks.add(task);
			} else if(taskType == TaskType.EVENT && Constant.stringToMillisecond(task.getEnd())
					> getCurrentTime() && !task.getDone()) {
				upcomingTasks.add(task);
			}
		}

		return upcomingTasks;
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getCompleted(ArrayList<Task> allTasks) {
		
		ArrayList<Task> completedTasks = new ArrayList<Task> ();
		
		for(Task task : allTasks) {
			if(task.getDone()) {
				completedTasks.add(task);
			}
		}
		
		return completedTasks;
	}

```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getOverdue(ArrayList<Task> allTasks, TaskType taskType) {

		ArrayList<Task> overdueTasks = new ArrayList<Task> ();

		for(Task task : allTasks) {
			if(Constant.stringToMillisecond(task.getEnd())
					<= getCurrentTime() && !task.getDone()) {
				overdueTasks.add(task);
			} 
		}

		return overdueTasks;
	}	

```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getTasks(TaskType taskType) {
		
		ArrayList<Task> tasks = new ArrayList<Task> ();
		taskList = storageComponent.load();
		
		for(Task task : taskList) {
			if(task.getTaskType().equals(taskType)) {
				tasks.add(task);
			}
		}
		
		return tasks;
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getTodayToDos() {

		ArrayList<Task> allToDos = getToDos();
		ArrayList<Task> todayToDos = new ArrayList<Task> ();

		for(Task task : allToDos) {
			if(!task.getDone() && Constant.stringToMillisecond(task.getEnd())
					>= getTodayStartTime()
					&& Constant.stringToMillisecond(task.getEnd())
					< getTodayEndTime()) {
				todayToDos.add(task);
			}
		}

		return todayToDos;
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getTodayEvents() {

		ArrayList<Task> allEvents = getEvents();
		ArrayList<Task> todayEvents = new ArrayList<Task> ();

		for(Task task : allEvents) {
			if(!task.getDone() && Constant.stringToMillisecond(task.getStart()) 
					>= getTodayStartTime()
					&& Constant.stringToMillisecond(task.getStart()) 
					< getTodayEndTime()) {
				todayEvents.add(task);
			}
		}

		return todayEvents;
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getAllToday() {
		
		ArrayList<Task> todayTasks = getTodayToDos();
		todayTasks.addAll(getTodayEvents());
		
		return todayTasks;
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getAllOverdue() {

		ArrayList<Task> overdueTasks = getOverdue(getToDos(), TaskType.TODO);
		ArrayList<Task> overdueEvents = getOverdue(getEvents(), TaskType.EVENT);
		
		overdueTasks.addAll(overdueEvents);
		
		return overdueTasks;
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getPastEvents() {
		
		ArrayList<Task> allEvents = getEvents();
		ArrayList<Task> pastEvents = new ArrayList<Task> ();

		for(Task task : allEvents) {
			if(task.getDone()) {
				pastEvents.add(task);
			}
		}

		return pastEvents;
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getUnDoneFloatingTasks() {
		
		ArrayList<Task> tasks = new ArrayList<Task> ();
		taskList = storageComponent.load();
		
		for(Task task : taskList) {
			if(task.getTaskType().equals(TaskType.FLOATING) && !task.getDone()) {
				tasks.add(task);
			}
		}
		
		return tasks;
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getFloatingTasks() {
		
		return getTasks(TaskType.FLOATING);
	}

```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getToDos() {
		
		return getTasks(TaskType.TODO);
	}

```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getEvents() {
		
		return getTasks(TaskType.EVENT);
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getCompletedFloats() {

		return getCompleted(getFloatingTasks());
	}

```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getCompletedToDos() {

		return getCompleted(getToDos());
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getUpcomingToDos() {

		return getUpcoming(getToDos(), TaskType.TODO);
	}

```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getUpcomingEvents() {

		return getUpcoming(getEvents(), TaskType.EVENT);
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private ArrayList<Task> getAllReminder() {
		
		ArrayList<Task> remindTaskList = new ArrayList<Task> ();
		ArrayList<Task> allData = storageComponent.load();
		ArrayList<Task> taskList = getFloatingTasks();
		taskList.addAll(getToDos());
		taskList.addAll(getEvents());
		
		for(Task task : taskList) {
			long reminder = Constant.stringToMillisecond(task.getReminder());
			if(!task.getDone() && reminder != -1 && reminder <= getCurrentTime()) {
				remindTaskList.add(task);
				task.setReminder(RESET);
				allData.set(task.getTaskId(), task);
			}
		}
	
		storageComponent.save(allData);
		return remindTaskList;
	}

```
###### src\main\java\backend\Logic\SearchCommand.java
``` java
	public String execute() {
		
		taskList = storageComponent.load();
		searchResults = new ArrayList<Task> ();
		String[] tokenize = this.getKeywords().toLowerCase().split(" ");
		int wordSize = tokenize.length;

		for(Task task : taskList) {
			int passed = 0;
			for(String word : tokenize)
				if(task.getName().toLowerCase().contains(word)
						|| task.getDescription().toLowerCase().contains(word)
						|| task.getStart().toLowerCase().contains(word)
						|| task.getEnd().toLowerCase().contains(word)
						|| task.getReminder().toLowerCase().contains(word)) {
					passed++;
				}
			if(wordSize == passed) {
				searchResults.add(task);
			}
		}

		return feedback(searchResults);
	}

}
```
###### src\main\java\backend\Logic\SortCommand.java
``` java
	private ArrayList<Task> generateTaskId(ArrayList<Task> taskList) {

		ArrayList<Task> newTaskList = new ArrayList<Task> ();
		int newTaskId = 0;

		for(Task task : taskList) {
			task.setTaskId(newTaskId);
			task.setSorted(true);
			newTaskList.add(task);
			newTaskId++;
		}

		return newTaskList;
	}
	
```
###### src\main\java\backend\Logic\SortCommand.java
``` java
	private ArrayList<Task> sortName(ArrayList<Task> taskList) {
		
		Collections.sort(taskList, new Comparator<Task> () {
			@Override
			public int compare(Task left, Task right) {
				if(left.getName().compareTo(right.getName()) < 0) {
					return -1;
				} else if(left.getName().compareTo(right.getName()) > 0) {
					return 1;
				}  else {
					return 0;
				}
			}
		});
		
		return generateTaskId(taskList);
	}
	
```
###### src\main\java\backend\Logic\SortCommand.java
``` java
	private ArrayList<Task> sortPriority(ArrayList<Task> taskList) {
		
		Collections.sort(taskList, new Comparator<Task> () {
			@Override
			public int compare(Task left, Task right) {
				if(left.getPriority() < right.getPriority()) {
					return 1;
				} else if(left.getPriority() > right.getPriority()) {
					return -1;
				} else {
					return 0;
				}
			}
		});
		
		return generateTaskId(taskList);
	}
	
```
###### src\main\java\backend\Logic\SortCommand.java
``` java
	private ArrayList<Task> sortDeadline(ArrayList<Task> taskList) {
		
		Collections.sort(taskList, new Comparator<Task> () {
			@Override
			public int compare(Task left, Task right) {
				if(Constant.stringToMillisecond(left.getEnd())
						< Constant.stringToMillisecond(right.getEnd())) {
					return -1;
				} else if(Constant.stringToMillisecond(left.getEnd()) 
						> Constant.stringToMillisecond(right.getEnd())) {
					return 1;
				} else {
					return 0;
				}
			}
		});
		
		return generateTaskId(taskList);
	}
	
```
###### src\main\java\backend\Logic\SortCommand.java
``` java
	private ArrayList<Task> sort(String field, ArrayList<Task> taskList) {
		
		ArrayList<Task> sortedTaskList = new ArrayList<Task> ();
		
		switch (field) {
			case SORT_NAME:
				sortedTaskList = sortName(taskList);
				break;
			case SORT_PRIORITY:
				sortedTaskList = sortPriority(taskList);
				break;
			case SORT_DATE:
				sortedTaskList = sortDeadline(taskList);
				break;
		}
		return sortedTaskList;
	}

}
```
###### src\main\java\backend\Storage\Storage.java
``` java

package main.java.backend.Storage;

import java.util.ArrayList;

import main.java.backend.Storage.Task.Task;;

public interface Storage {

	public void init();
	
	public ArrayList<Task> load();
	
	public void save(ArrayList<Task> allData);
	
	public String updateFilePath(String newFilePath);
	
}
```
###### src\main\java\backend\Storage\StorageExecution.java
``` java

package main.java.backend.Storage;

import java.io.File;
import java.util.ArrayList;

import main.java.backend.Storage.Task.Task;

public abstract class StorageExecution {

	public String filePath;
	public File textFile;
	
	public StorageFormat storageFormat;
	public StorageFilePath storageFilePath;

	public abstract ArrayList<Task> execute(ArrayList<Task> taskList);
}
```
###### src\main\java\backend\Storage\StorageFacade.java
``` java

package main.java.backend.Storage;

import java.util.ArrayList;
import java.util.HashMap;

import main.java.backend.Storage.Task.Task;

/**
 * This class loads from and saves data to text file.
 * 
 */

public class StorageFacade implements Storage {

	private StorageLoad load;
	private StorageSave save;
	private StorageFilePath filePath;
	
	private void reinit() {
		load = new StorageLoad();
		save = new StorageSave();
	}
	
	@Override
	public void init() {
		load = new StorageLoad();
		save = new StorageSave();
		filePath = new StorageFilePath();
	}
	
	@Override
	public ArrayList<Task> load() {
		return load.execute(null);
	}
	
	@Override
	public void save(ArrayList<Task> allData) {
		save.execute(allData);
	}
	
	@Override
	public String updateFilePath(String newFilePath) {
		String result = filePath.execute(newFilePath);
		reinit();
		return result;
	}
 }
```
###### src\main\java\backend\Storage\StorageFilePath.java
``` java
	public StorageFilePath() {
		
		properties = new Properties();
	}
	
```
###### src\main\java\backend\Storage\StorageFilePath.java
``` java
	/**
	 * Removes file name to check if new file path exist
	 * before transferring data over to the new file path.
	 * 
	 * @param tokenize		Tokenize the file path to remove last token (file name)
	 * @param slash			Token to represent front or back slash to distinguish 
	 * 						mac or windows file path
	 * @return				Returns filepath with file name removed	
	 */
	private String removeFileName(String[] tokenize, String slash) {
		
		String filePath = new String();
		int size = tokenize.length - 1;
		
		for(int i = 0; i < size; i++) {
			filePath += slash + tokenize[i];
		}
		
		return filePath;
	}
	
```
###### src\main\java\backend\Storage\StorageFilePath.java
``` java
	/**
	 * Check if file path exist before transferring data 
	 * over from current file to new file
	 * 
	 * @param filePath		New file path provided by user.
	 * @return				Returns true if exist, else false.
	 */
	private boolean isFilePathExist(String filePath) {
		
		filePath = filePath.replace(BACKSLASH_1, BACKSLASH_2);
		String tokenizeFrontSlash = removeFileName(filePath.split(FRONTSLASH), FRONTSLASH);
		String tokenizeBackSlash = removeFileName(filePath.split(BACKSLASH_2), 
				BACKSLASH_1).replaceAll(BACKSLASH_3, BACKSLASH_2);
		
		File filePathMac = new File(tokenizeFrontSlash);
		File filePathWindows = new File(tokenizeBackSlash);
		
		if (filePathMac.exists() || filePathWindows.exists()){
		    return true;
		} else {
			return false;
		}
	}
	
```
###### src\main\java\backend\Storage\StorageFilePath.java
``` java
	/**
	 * Retrieves current file path of the text file
	 * where all data is saved.
	 * 
	 * @return		Current file path
	 */
	private String retrieveFilePath() {
		
		String filePath = properties.getProperty(FILE_KEY);
		
		if(filePath == null) {
			return DEFAULT_PATH_LOCATION;
		} else {
			return filePath;
		}
	}
	
```
###### src\main\java\backend\Storage\StorageFilePath.java
``` java
	/**
	 * Append the previous set text file name to the 
	 * new file path provided by the user if the user
	 * did not specify the name of the text file for
	 * the new file path.
	 * 
	 * @param newFilePath		New file path to transfer data over.
	 * @return					New file path with name of text file attached.
	 */
	private String appendTextFile(String newFilePath) {
		
		if(!newFilePath.contains(DEFAULT_FILE_EXTENTION)) {
			return newFilePath + addSlash(newFilePath);
		} else {
			return newFilePath;
		}
	}
	
```
###### src\main\java\backend\Storage\StorageFilePath.java
``` java
	/**
	 * Retrieves the file name of current file path 
	 * if the user did not specify file name in the
	 * new file path.
	 * 
	 * @return			Current name of text file
	 */
	private String getFileName() {
		
		String filePath = retrieve();
		String[] tokenizeFrontSlash = filePath.split(FRONTSLASH);
		String[] tokenizeBackSlash = filePath.split(BACKSLASH_2);
		
		if(filePath.contains(FRONTSLASH)) {
			return tokenizeFrontSlash[tokenizeFrontSlash.length - 1];
		} else if(filePath.contains(BACKSLASH_1)) {
			return tokenizeBackSlash[tokenizeBackSlash.length - 1];
		}
		
		return DEFAULT_FILE_NAME;
	}
	
```
###### src\main\java\backend\Storage\StorageFilePath.java
``` java
	/**
	 * Append frontslash or backslash if the
	 * new file path provided by the user does not
	 * have file name specified, and no slashes typed 
	 * at the last character of the file path.
	 * 
	 * @param newFilePath		New file path provided by user.
	 * @return					Proper file path with all required slashes.
	 */
	private String addSlash(String newFilePath) {
		
		if(newFilePath.contains(FRONTSLASH) 
				&& !newFilePath.endsWith(FRONTSLASH)) {
			return FRONTSLASH + getFileName();
		} else if(newFilePath.contains(FRONTSLASH) 
				&& newFilePath.endsWith(FRONTSLASH)) {
			return getFileName();
		} else if(newFilePath.contains(BACKSLASH_1) 
				&& !newFilePath.endsWith(BACKSLASH_1)) {
			return BACKSLASH_1 + getFileName();
		} else if(newFilePath.contains(BACKSLASH_1) 
				&& newFilePath.endsWith(BACKSLASH_1)) {
			return getFileName();
		} else {
			return newFilePath;
		}
	}
	
```
###### src\main\java\backend\Storage\StorageFilePath.java
``` java
	/**
	 * Retrieves the current file path of data storage.
	 * 
	 * @return		Current file path
	 */
	public String retrieve() {
		
		try {
			reader = new FileReader(FILE_CONFIGURATION);
			properties.load(reader);
		} catch (IOException e) {
			System.out.println(ERROR_READ_DATA);
		}
		
		return retrieveFilePath();
	}

```
###### src\main\java\backend\Storage\StorageFilePath.java
``` java
	public String execute(String newFilePath) {

		String oldFilePath = retrieve();
		newFilePath = appendTextFile(newFilePath);
		boolean isTransferred = false;

		if(oldFilePath.equals(newFilePath)) {
			return String.format(EXECUTION_FILEPATH_DUPLICATE, newFilePath);
		} else if(isFilePathExist(newFilePath)) {
			try {
				writer = new FileWriter(FILE_CONFIGURATION);
				isTransferred = dataTransfer(oldFilePath, newFilePath);
				properties.setProperty(FILE_KEY, newFilePath);
				properties.store(writer, FILE_HEADING);
				writer.close();
			} catch (IOException e) {
				return EXECUTION_FILEPATH_UNSUCCESSFUL;
			}	
		} else if(!isTransferred) {
			return EXECUTION_FILEPATH_UNSUCCESSFUL;
		} 
		
		return String.format(EXECUTION_FILEPATH_SUCCESSFUL, newFilePath);
	}

}
```
###### src\main\java\backend\Storage\StorageFormat.java
``` java

package main.java.backend.Storage;

import java.io.IOException;
import java.util.ArrayList;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;

import main.java.backend.Storage.Task.Task;

/**
 * This class serialize Task objects to JSON format
 * or deserialize JSON format to Task objects.
 * 
 * @author A0126258A
 *
 */

public class StorageFormat {
	
	private static final String ERROR_SERIALIZE = "An error occured when serializing Task objects to text.";
	private static final String ERROR_DESERIALIZE = "An error occured when deserializing text to Task objects.";

	public StorageFormat() {

	}

	public String serialize(ArrayList<Task> allData) {
		
		String plaintext = new String();
		try {
			ObjectMapper mapper = new ObjectMapper();
			mapper.enable(SerializationFeature.INDENT_OUTPUT);
			plaintext = mapper.writeValueAsString(allData);
		} catch (IOException e) {
			System.out.println(ERROR_SERIALIZE);
		}
		
		return plaintext;
	}

	public ArrayList<Task> deserialize(String plaintext) {

		ArrayList<Task> allData = new ArrayList<Task>();
		ObjectMapper mapper = new ObjectMapper();
		mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

		try {
			allData = mapper.readValue(plaintext, 
					new TypeReference<ArrayList<Task>>() {});
		} catch (IOException e) {
			System.out.println(ERROR_DESERIALIZE);
		}

		return allData;
	}
}
```
###### src\main\java\backend\Storage\StorageLoad.java
``` java

package main.java.backend.Storage;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;

import main.java.backend.Storage.Task.Task;

/**
 * This class parse all texts in the file from JSON 
 * format to Java object to retrieve user's data
 * by reading data from the text file.
 * 
 * @author A0126258A
 * 
 */

public class StorageLoad extends StorageExecution {

	private static final String ERROR_FILE_READ = "An error occured when reading data from file.";
	private static final String ERROR_FILE_CLOSE = "An error occured when closing file reader.";
	private static final String ERROR_FILE_LOAD = "An error occured when loading data from file.";
	
	private BufferedReader bufferedReader;
	private FileReader textFileReader;

	public StorageLoad() {

		storageFormat = new StorageFormat();
		storageFilePath = new StorageFilePath();
		filePath = storageFilePath.retrieve();
	}

	private void initReader() {

		try {
			textFile = new File(filePath);
			
			if(!textFile.exists()) {
				textFile.createNewFile();
			}
			
			textFileReader = new FileReader(textFile);
			bufferedReader = new BufferedReader(textFileReader);
		} catch (IOException e) {
			System.out.println(ERROR_FILE_READ);
		}
	}

	private void closeReader()  {
		
		try {
			textFileReader.close();
			bufferedReader.close();
		} catch (IOException e) {
			System.out.println(ERROR_FILE_CLOSE);
		}
	}

	public ArrayList<Task> execute(ArrayList<Task> nullData) {

		ArrayList<Task> allData = new ArrayList<Task> ();
		initReader();

		try {
			if(bufferedReader.readLine() != null) {
				allData = storageFormat.deserialize(new String(Files.readAllBytes
						(Paths.get(filePath)), StandardCharsets.UTF_8));
			} 
		} catch (IOException e) {
			System.out.println(ERROR_FILE_LOAD);
		}

		closeReader();
		return allData;
	}

}
```
###### src\main\java\backend\Storage\StorageSave.java
``` java

package main.java.backend.Storage;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;

import main.java.backend.Storage.Task.Task;

/**
 * This class parse Java object back to JSON format 
 * to be saved in the file as text when there is any 
 * update in the data by writing data to the text file.
 * 
 * @author A0126258A
 * 
 */

public class StorageSave extends StorageExecution {
	
	private static final String ERROR_FILE_WRITE = "An error occured when writing data from file.";
	private static final String ERROR_FILE_CLOSE = "An error occured when closing file writer.";
	private static final String ERROR_FILE_SAVE = "An error occured when saving data to file.";
	
	private BufferedWriter bufferedWriter;
	private FileWriter textFileWriter;
	
	public StorageSave() {
		
		storageFilePath = new StorageFilePath();
		storageFormat = new StorageFormat();
		filePath = storageFilePath.retrieve();
	}

	private void initWriter() {
		
		try {
			textFile = new File(filePath);
			textFileWriter = new FileWriter(textFile);
			bufferedWriter = new BufferedWriter(textFileWriter);
		} catch (IOException e) {
			System.out.println(ERROR_FILE_WRITE);
		}
	}

	private void closeWriter() {
		
		try { 
			bufferedWriter.flush();
			textFileWriter.close();
			bufferedWriter.close();
		} catch (IOException e) {
			System.out.println(ERROR_FILE_CLOSE);
		}
	}
	
	public ArrayList<Task> execute(ArrayList<Task> allData) {
		
		initWriter();
		
		try {
			if(allData != null) {
				bufferedWriter.write(storageFormat.serialize(allData));
			}
		} catch (IOException e) {
			System.out.println(ERROR_FILE_SAVE);
		}
		
		closeWriter();
		return allData;
	}
}
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public enum TaskType {
		FLOATING, TODO, EVENT;
	}
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public enum RecurrenceType {
		NONE, DAY, WEEK, MONTH, YEAR;
	}
	
	private static final String PRINT_PRIORITY_LEVEL = "*";
	private static final String PRINT_DESCRIPTION = "Description: ";
	private static final String PRINT_DEADLINE = "Deadline: ";
	private static final String PRINT_FROM = "From: ";
	private static final String PRINT_TO = "To: ";
	private static final String PRINT_REMINDER = "Reminder: ";
	private static final String PRINT_RECURRING = "Recurring every: ";
	private static final String PRINT_EMPTY = "";
	private static final String PRINT_SPACE = " ";
	private static final String PRINT_DOT = ". ";
	private static final String PRINT_PLURAL = "s";
	private static final String PRINT_NEW_LINE = System.getProperty("line.separator");
	
	private TaskType taskType;
	private RecurrenceType recurrenceType;
	private int recurrenceFrequency;
	private int taskId;
	private int indexForPrinting;
	private int priority;
	
	private boolean isDone;
	private boolean isRecurred;
	private boolean isSorted;
	
	private String name;
	private String description;
	private String start;
	private String end;
	private String reminder;
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public Task () {
		
	}
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public Task(Task task) {
		this(task.getTaskType(), task.getRecurrenceType(), task.getRecurrenceFrequency(),
				task.getPriority(), task.getName(), task.getDescription(), task.getStart(), 
				task.getEnd(), task.getReminder());
	}
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public Task(TaskType taskType, RecurrenceType recurrenceType, int recurrenceFrequency, 
			int priority, String name, String description, 
			String start, String end, String reminder) {
		
		assert taskType != null;
		assert name != null;
		
		this.taskType = taskType;
		this.recurrenceType = recurrenceType;
		this.recurrenceFrequency = recurrenceFrequency;
		this.priority = priority;
		this.isDone = false;
		this.isRecurred = false;
		this.setSorted(false);
		this.name = name;
		this.description = description;
		this.start = start;
		this.end = end;
		this.reminder = reminder;
	}
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public TaskType getTaskType() {
		return taskType;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public void setTaskType(TaskType taskType) {
		this.taskType = taskType;
	}
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public RecurrenceType getRecurrenceType() {
		return recurrenceType;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public void setRecurrenceType(RecurrenceType recurrenceType) {
		this.recurrenceType = recurrenceType;
	}
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public int getRecurrenceFrequency() {
		return recurrenceFrequency;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public void setRecurrenceFrequency(int recurrenceFrequency) {
		this.recurrenceFrequency = recurrenceFrequency;
	}
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public int getTaskId() {
		return taskId;
	}
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public void setTaskId(int newTaskId) {
		this.taskId = newTaskId;
	}
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public int getIndex() {
		return indexForPrinting;
	}
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public void setIndex(int index){
		indexForPrinting = index;
	}
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public int getPriority() {
		return priority;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public void setPriority(int priority) {
		this.priority = priority;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public boolean getDone() {
		return isDone;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public void setDone(boolean isDone) {
		this.isDone = isDone;
	}
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public boolean isRecurred() {
		return isRecurred;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public void setRecurred(boolean isRecurred) {
		this.isRecurred = isRecurred;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public boolean isSorted() {
		return isSorted;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public void setSorted(boolean isSorted) {
		this.isSorted = isSorted;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public String getName() {
		return name;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public void setName(String name) {
		this.name = name;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public String getDescription() {
		return description;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public void setDescription(String description) {
		this.description = description;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public String getStart() {
		return start;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public void setStart(String start) {
		this.start = start;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public String getEnd() {
		return end;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public void setReminder(String reminder) {
		this.reminder = reminder;
	}
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public String getReminder() {
		return reminder;
	}

```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	public void setEnd(String end) {
		this.end = end;
	}
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	@Override
	public boolean equals(Object o) {
		
		if (!(o instanceof Task)) {
			return false;
		}
		
		Task task = (Task) o;
		return this.taskType.equals(task.getTaskType()) 
				&& this.recurrenceType.equals(task.getRecurrenceType())
				&& this.recurrenceFrequency == task.getRecurrenceFrequency()
				&& this.taskId == task.getTaskId()
				&& this.indexForPrinting == task.getIndex()
				&& this.priority == task.getPriority()
				&& this.isDone == task.getDone()
				&& this.name.equals(task.getName())
				&& this.description.equals(task.getDescription())
				&& this.start.equals(task.getStart())
				&& this.end.equals(task.getEnd())
				&& this.reminder.equals(task.getReminder());
	}
	
```
###### src\main\java\backend\Storage\Task\Task.java
``` java
	@Override
	public int compareTo(Task o) {
		if(Constant.stringToMillisecond(getStart())
				< Constant.stringToMillisecond(o.getStart())) {
			return -1;
		} else if(Constant.stringToMillisecond(getStart()) 
				> Constant.stringToMillisecond(o.getStart())) {
			return 1;
		} else if(Constant.stringToMillisecond(getEnd())
				< Constant.stringToMillisecond(o.getEnd())) {
			return -1;
		} else if(Constant.stringToMillisecond(getEnd()) 
				> Constant.stringToMillisecond(o.getEnd())) {
			return 1;
		} else {
			return 0;
		}
	}
}
```
