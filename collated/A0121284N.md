# A0121284N
###### src\main\java\backend\Logic\AddCommand.java
``` java
	public AddCommand(Type typeInput, Storage storage, History history) {
		
		super(typeInput);
		storageComponent = storage;
		historySubComponent = history;
	}

```
###### src\main\java\backend\Logic\AddCommand.java
``` java
	public String undo() {
		
		try {
			ArrayList<Task> historyState = historySubComponent.undo();
			storageComponent.save(historyState);
			return EXECUTION_UNDO_SUCCESSFUL;
		} catch (EmptyStackException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}

```
###### src\main\java\backend\Logic\AddCommand.java
``` java
	public String redo() {
		
		try {
			ArrayList<Task> futureState = historySubComponent.redo();
			storageComponent.save(futureState);
			return EXECUTION_REDO_SUCCESSFUL;
		} catch (EmptyStackException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}
	
```
###### src\main\java\backend\Logic\AddCommand.java
``` java
	public String execute() {	
		
		String feedbackString = new String();
		logicAdderLogger.info(LOGGER_COMMAND_EXECUTION + this.getCommandField());
		
		switch (this.getCommandField()) {
			case (COMMAND_ADD_FLOAT) :
				feedbackString = addTask(TaskType.FLOATING, this);
				break;
			case (COMMAND_ADD_TODO) :
				feedbackString = addTask(TaskType.TODO, this);
				break;	
			case (COMMAND_ADD_EVENT) :
				feedbackString = addTask(TaskType.EVENT, this);
				break;
		}
		
		logicAdderLogger.info(LOGGER_COMMAND_ADD + feedbackString);
		currentState = storageComponent.load();
		historySubComponent.push(currentState);
		
		return feedbackString;
	}
}
```
###### src\main\java\backend\Logic\Command.java
``` java
package main.java.backend.Logic;

import java.util.ArrayList;

import main.java.backend.Storage.Task.Task;

public class Command {
	
	public enum Type {
		ADD, EDIT, SORT, SEARCH, EXIT, UNDO, REDO, VIEW, ERROR, FILEPATH
	}
	
	private Type type;
	private String commandField = "";
	private String taskName = "";
	private String recurrenceType = "";
	private String recurrenceFrequency = "";
	private String description = "";
	private String priority = "";
	private String rename = ""; 
	private String category = "";
	private String startDateAndTime = "";
	private String endDateAndTime = "";
	private String keywords = "";
	private String newName = "";
	private String errorMessage = "";
	private String filePath = "";
	private String resetField = "";

    // ================================================================
    // General set command methods
    // ================================================================
	
	public Command() {
		
	}
	
	public Command(Type typeInput) {
		this.type = typeInput;
	}

	public void setCommandField(String commandInput) {
		this.commandField = commandInput;
	}
	
	public void setTaskName(String taskNameInput) {
		this.taskName = taskNameInput;
	}
	
	public void setRecurrenceType(String recurrenceType) {
		this.recurrenceType = recurrenceType;
	}

	public void setRecurrenceFrequency(String recurrenceFrequency) {
		this.recurrenceFrequency = recurrenceFrequency;
	}
	
	public void setDescription(String descriptionInput) {
		this.description = descriptionInput;
	}
	
	public void setPriority(String priorityInput) {
		this.priority = priorityInput;
	}
	
	public void setReminder(String reminderInput) {
		this.rename = reminderInput;
	}
	
	public void setRecurrence(String categoryInput) {
		this.category = categoryInput;
	}
	
	public void setFilePath(String filePath) {
		this.filePath = filePath;
	}
	
	public void setKeywords(String keywordInput) {
		this.keywords = keywordInput;
	}
	
	public void setNewName(String name) {
		this.newName = name;
	}
	
	public void setErrorMessage(String errorMessage) {
		this.errorMessage = errorMessage;
	}
	
    // ================================================================
    // Additional for events creation set command methods
    // ================================================================
	
	public void setStartDateAndTime(String startDateAndTimeInput) {
		this.startDateAndTime = startDateAndTimeInput;
	}
	
	public void setEndDateAndTime(String endDateAndTimeInput) {
		this.endDateAndTime = endDateAndTimeInput;
	}

    // ================================================================
    // Additional for tasks creation set command methods
    // ================================================================

	public void setResetField(String command) {
		this.resetField = command;
	}

	public Type getType() {
		return this.type;
	}
	
	public String getCommandField() {
		return this.commandField;
	}
	
	public String getTaskName() {
		return this.taskName;
	}
	
	public String getRecurrenceType() {
		return this.recurrenceType;
	}

	public String getRecurrenceFrequency() {
		return this.recurrenceFrequency;
	}
	
	public String getDescription() {
		return this.description;
	}
	
	public String getPriority() {
		return this.priority;
	}
	
	public String getReminder() {
		return this.rename;
	}
	
	public String getRecurrence() {
		return this.category;
	}
	
	public String getStartDateAndTime() {
		return this.startDateAndTime;
	}
	
	public String getEndDateAndTime() {
		return this.endDateAndTime;
	}
	
	public String getKeywords() {
		return this.keywords;
	}
	
	public String getNewName() {
		return this.newName;
	}
	
	public String getResetField() {
		return this.resetField;
	}

	public String getFilePath() {
		return filePath;
	}
	
	public String getErrorMessage() {
		return errorMessage;
	}
	
	public ArrayList<Task> getSearchResults() {
		return null;
	}
	
	public String execute() {
		return null;
	}

	public String undo() {
		return null;
	}
	
	public String redo() {
		return null;
	}
	
}
```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	public EditCommand(Type typeInput, Storage storage, History history) {

		super(typeInput);
		storageComponent = storage;
		historySubComponent = history;
		taskList = storageComponent.load();
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private String setMultipleFieldsForFloats(Command commandObject) {

		try {
			int taskId = Integer.parseInt(commandObject.getTaskName());
			logicEditorLogger.info(LOGGER_TASKID + taskId);
			
			if(!commandObject.getNewName().isEmpty()) {
				rename(commandObject);
			}
			if (!commandObject.getDescription().isEmpty()) {
				logicEditorLogger.info(LOGGER_DESCRIPTION + commandObject.getDescription());
				setDescription(commandObject);
			}
			if (!commandObject.getPriority().isEmpty()) {
				logicEditorLogger.info(LOGGER_PRIORITY + commandObject.getPriority());
				setPriority(commandObject);
			}
			if (!commandObject.getReminder().isEmpty()) {
				logicEditorLogger.info(LOGGER_REMINDER + commandObject.getReminder());
				setReminder(commandObject);
			}
			return EXECUTION_SET_SUCCESSFUL;
		} catch (NumberFormatException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private String setMultipleFieldsForTodo(Command commandObject) {

		try {
			setMultipleFieldsForFloats(commandObject);
			
			if(!commandObject.getRecurrence().isEmpty()) {
				logicEditorLogger.info(LOGGER_RECURRING + commandObject.getRecurrence());
				setRecurring(commandObject);
			}
			if (!commandObject.getEndDateAndTime().isEmpty()) {
				setDeadline(commandObject);
				logicEditorLogger.info(LOGGER_DEADLINE + commandObject.getEndDateAndTime());
			}
			return EXECUTION_SET_SUCCESSFUL;
		} catch (NumberFormatException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private String setMultipleFieldsForEvents(Command commandObject) {

		try {
			setMultipleFieldsForFloats(commandObject);
			
			if(!commandObject.getRecurrence().isEmpty()) {
				logicEditorLogger.info(LOGGER_RECURRING +commandObject.getRecurrence());
				setRecurring(commandObject);
			}
			if (!commandObject.getStartDateAndTime().isEmpty() && 
					!commandObject.getEndDateAndTime().isEmpty()) {
				logicEditorLogger.info(LOGGER_STARTDATE +commandObject.getStartDateAndTime());
				logicEditorLogger.info(LOGGER_ENDDATE +commandObject.getStartDateAndTime());
				setEventStartAndEndTime(commandObject);
			}
			return EXECUTION_SET_SUCCESSFUL;
		} catch (NumberFormatException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private String reset(Command commandObject) {
		
		int taskIndex = Integer.parseInt(commandObject.getTaskName());
		int taskId = getTaskId(taskIndex);
		String resetField = commandObject.getResetField();
		
		switch(resetField) {
			case COMMAND_PRIORITY :
				taskList.get(taskId).setPriority(0);
				break;
			case COMMAND_DESCRIPTION :
				taskList.get(taskId).setDescription(RESET);
				break;
			case COMMAND_REMINDER :
				taskList.get(taskId).setReminder(RESET);
				break;
			case COMMAND_DATE :
				taskList.get(taskId).setTaskType(TaskType.FLOATING);
				taskList.get(taskId).setStart(RESET);
				taskList.get(taskId).setEnd(RESET);
				break;
			case COMMAND_ALL :
				taskList.get(taskId).setTaskType(TaskType.FLOATING);
				taskList.get(taskId).setStart(RESET);
				taskList.get(taskId).setEnd(RESET);
				taskList.get(taskId).setPriority(0);
				taskList.get(taskId).setDescription(RESET);
				taskList.get(taskId).setReminder(RESET);
				break;
		}
		
		storageComponent.save(taskList);
		return String.format(EXECUTION_RESET_SUCCESSFUL, resetField);
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private String delete(Command commandObject) {
		
		try{
			int taskIndex = Integer.parseInt(commandObject.getTaskName());
			int taskId = getTaskId(taskIndex);

			taskList.remove(taskId);
			setTaskId(taskList);
			storageComponent.save(taskList);
			
			return String.format(EXECUTION_DELETE_SUCCESSFUL, taskIndex);
		} catch (ArrayIndexOutOfBoundsException | NumberFormatException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private String deleteAll(EditCommand editCommand) {
		
		storageComponent.save(null);
		return EXECUTION_DELETE_ALL_SUCCESSFUL;
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	private String rename(Command commandObject) {
		
		String newName = commandObject.getNewName();
		int taskIndex = Integer.parseInt(commandObject.getTaskName());
		int taskId = getTaskId(taskIndex);
		
		taskList.get(taskId).setName(newName);
		storageComponent.save(taskList);
		
		return String.format(EXECUTION_RENAME_SUCCESSFUL, taskIndex, newName);
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	public String undo() {
		
		try {
			ArrayList<Task> historyState = historySubComponent.undo();
			storageComponent.save(historyState);
			return EXECUTION_UNDO_SUCCESSFUL;
		} catch (EmptyStackException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}

```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	public String redo() {
		
		try {
			ArrayList<Task> futureState = historySubComponent.redo();
			storageComponent.save(futureState);
			return EXECUTION_REDO_SUCCESSFUL;
		} catch (EmptyStackException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}
	
```
###### src\main\java\backend\Logic\EditCommand.java
``` java
	public String execute(){

		String feedbackString = RESET;
		logicEditorLogger.info(LOGGER_COMMAND_FIELD + this.getCommandField());

		if(taskExist(this)) {
			switch(this.getCommandField()) {
				case (COMMAND_PRIORITY) :
					feedbackString = setPriority(this);
					break;
				case (COMMAND_ONESHOT_TASK) :
					feedbackString = setMultipleFieldsForTodo(this);
					break;
				case (COMMAND_ONESHOT_EVENT) :
					feedbackString = setMultipleFieldsForEvents(this);
					break;
				case (COMMAND_ONESHOT_FLOAT) :
					feedbackString = setMultipleFieldsForFloats(this);
					break;
				case (COMMAND_DELETE) :
					feedbackString = delete(this);
					break;
				case (COMMAND_DELETE_ALL):
					feedbackString = deleteAll(this);
					break;
				case (COMMAND_UNDONE) :
					feedbackString = setUndone(this);
					break;
				case (COMMAND_DONE) :
					feedbackString = setDone(this);
					break;
				case (COMMAND_REMINDER) :
					feedbackString = setReminder(this);
					break;
				case (COMMAND_DESCRIPTION) :
					feedbackString = setDescription(this);
					break;
				case (COMMAND_EVENT) :
					feedbackString = setEventStartAndEndTime(this);
					break;
				case (COMMAND_DEADLINE) :
					feedbackString = setDeadline(this);
					break;
				case (COMMAND_EVERY) :
					feedbackString = setRecurring(this);
					break;	
				case (COMMAND_RENAME):
					feedbackString = rename(this);
					break;
				case (COMMAND_RESET):
					feedbackString = reset(this);
					break;
			} 
		} else {
			feedbackString = EXECUTION_UNSUCCESSFUL;
		}

		currentState = taskList;
		historySubComponent.push(currentState);

		return feedbackString;
	}

}
```
###### src\main\java\backend\Logic\ErrorCommand.java
``` java
package main.java.backend.Logic;

public class ErrorCommand extends Command {
	private String errorMessage = "";

	public ErrorCommand(Type typeInput) {
		super(typeInput);
	}

	public void setErrorMessage(String message) {
		this.errorMessage = message;
	}
	
	public String getErrorMessage() {
		return this.errorMessage;
	}
}
```
###### src\main\java\backend\Logic\FilePathCommand.java
``` java
package main.java.backend.Logic;

import main.java.backend.Storage.Storage;

public class FilePathCommand extends Command {
	
	private String filepath;
	private Storage storageComponent;

	public FilePathCommand(Type typeInput, Storage storage) {
		super(typeInput);
		storageComponent = storage;
	}
	
	public void setFilePath(String path) {
		this.filepath = path;
	}
	
	public String getFilePath() {
		return this.filepath;
	}
	
	public String execute() {
		return storageComponent.updateFilePath(filepath);
	}

}
```
###### src\main\java\backend\Logic\History.java
``` java
package main.java.backend.Logic;

import java.util.ArrayList;
import java.util.EmptyStackException;
import java.util.Stack;
import java.util.logging.Logger;

import main.java.backend.Storage.Task.Task;
import main.java.backend.Util.LoggerGlobal;

public class History {
	
	private static final String LOGGER_CURRENT_STATE = "Received current state: ";
	private static final String LOGGER_STACK_TOP = "Top of the stack: ";
	private static final String LOGGER_STACK_SIZE = "Stack size after push: ";
	private static final String LOGGER_STACK_SIZE_AFTER_POP = "Stack size after push: ";
	private static final String LOGGER_ERROR_EMPTY_STACK = "Error Occured: Stack is empty";
	
	private static final Logger historyLogger = LoggerGlobal.getLogger();	
	private static History historyObject;
	
	private Stack<ArrayList<Task>> stateUndo = new Stack<ArrayList<Task>>();
	private Stack<ArrayList<Task>> stateRedo = new Stack<ArrayList<Task>>();
	
	private History() {
		
	}
	
	public static History getInstance() {
		
		if (historyObject == null) {
			historyObject = new History();
		}
		return historyObject;
	}
	
	public void exit() {
		System.exit(0);
	}

	public void push(ArrayList<Task> currentState) {
		
		historyLogger.info(LOGGER_CURRENT_STATE + currentState);
		stateUndo.push(currentState);
		historyLogger.info(LOGGER_STACK_TOP + stateUndo.peek());
		historyLogger.info(LOGGER_STACK_SIZE + stateUndo.size());
	}

	public ArrayList<Task> undo() {
		
		if (stateUndo.isEmpty() || stateUndo.peek() == null) {
			return null;
		}
		
		try {
			historyLogger.info(LOGGER_STACK_TOP + stateUndo.peek());
			stateRedo.push(stateUndo.pop());
			historyLogger.info(LOGGER_STACK_TOP + stateUndo.peek());
			historyLogger.info(LOGGER_STACK_SIZE_AFTER_POP + stateUndo.size());
		} catch(EmptyStackException e) {
			historyLogger.warning(LOGGER_ERROR_EMPTY_STACK);
			return null;
		}
		
		return stateUndo.peek();
	}
	
	public ArrayList<Task> redo() {
		
		if (stateRedo.isEmpty() || stateRedo.peek() == null) {
			return null;
		}
		
		try {
			historyLogger.info(LOGGER_STACK_TOP + stateRedo.peek());
			stateUndo.push(stateRedo.pop());
			historyLogger.info(LOGGER_STACK_TOP + stateUndo.peek());
			historyLogger.info(LOGGER_STACK_SIZE_AFTER_POP + stateUndo.size());
		} catch(EmptyStackException e) {
			historyLogger.warning(LOGGER_ERROR_EMPTY_STACK);
			return null;
		}

		return stateUndo.peek();
	}
}
```
###### src\main\java\backend\Logic\LogicCommandHandler.java
``` java
package main.java.backend.Logic;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.logging.Logger;
import main.java.backend.Storage.Storage;
import main.java.backend.Util.LoggerGlobal;

public class LogicCommandHandler {
	
	private static final String COMMAND_ADD = "add";
	private static final String COMMAND_ADD_TODO = "addT";
	private static final String COMMAND_ADD_EVENT = "addE";
	private static final String COMMAND_EDIT = "edit";
	private static final String COMMAND_SORT = "sort";
	private static final String COMMAND_SEARCH = "search";
	private static final String COMMAND_VIEW = "view";
	private static final String COMMAND_EXIT = "exit";
	private static final String COMMAND_UNDO = "undo";
	private static final String COMMAND_REDO = "redo";
	private static final String COMMAND_ERROR = "error";
	private static final String COMMAND_FILEPATH = "filepath";
	
	private static final String COMMAND_SET_FLOAT = "set";
	private static final String COMMAND_SET_TODO = "setT";
	private static final String COMMAND_SET_EVENT = "setE";
	private static final String COMMAND_DEADLINE = "deadline";
	private static final String COMMAND_EVENT = "event";
	private static final String COMMAND_DESCRIPTION = "description";
	private static final String COMMAND_REMINDER = "reminder";
	private static final String COMMAND_PRIORITY = "priority";
	private static final String COMMAND_RENAME = "rename";
	private static final String COMMAND_RESET = "reset";
	private static final String COMMAND_RECUR = "every";
	
	private static final String EMPTY = "";
	
	private static final String[] addKeywords = new String[] {"addF", "addT",
			"addE", "adds", "addcat"};
	private static final String[] editKeywords = new String[] {"set", "setT", 
			"setE", "deadline", "event", "description", "reminder", "done", "undone",
			"category","setCol","delete", "deleteAll", "priority", "reset", "rename","every"};
	private static final String[] sortKeywords = new String[] {"sortN", "sortP","sortD"};
	private static final String[] viewKeywords = new String[] {"showCat", "show floating", "showC",
			"showD", "show todo", "show events", "show overdue", "showT", "showE", "showO", "showF"};
	
	private static Logger logicCommandHandlerLogger = LoggerGlobal.getLogger();	
	
	private static LogicCommandHandler commandHandler;
	private static Storage storageComponent;
	private static History historySubComponent;
	
	private LogicCommandHandler(Storage storage, History history) {
		storageComponent = storage;
		historySubComponent = history;
	}

	public static LogicCommandHandler getInstance(Storage storage, History history) {
		if (commandHandler == null) {
			commandHandler = new LogicCommandHandler(storage,history);
		}
		return commandHandler;
	}
	
	public void exit() {
		System.exit(0);
	}

	public Command parse(ArrayList<String> parsedUserInput) {
		logicCommandHandlerLogger.info("Command from parser: "+parsedUserInput.get(0));
		String determinedCommandType = determineCommandType(parsedUserInput.get(0));
		logicCommandHandlerLogger.info("determined Command Type: "+determinedCommandType);
		Command commandObject = new Command();
		switch (determinedCommandType) {
			case COMMAND_ADD :
				commandObject = initAddCommand(parsedUserInput);
				break;
			case COMMAND_EDIT :
				commandObject = initEditCommand(parsedUserInput);
				break;
			case COMMAND_SORT :
				commandObject= initSortCommand(parsedUserInput);
				break;
			case COMMAND_SEARCH :
				commandObject = initSearchCommand(parsedUserInput);
				break;
			case COMMAND_EXIT :
				commandObject = initExitCommand(parsedUserInput);
				break;
			case COMMAND_UNDO :
				commandObject = initUndoCommand(parsedUserInput);
				break;
			case COMMAND_REDO :
				commandObject = initRedoCommand(parsedUserInput);
				break;
			case COMMAND_VIEW :
				commandObject = initViewCommand(parsedUserInput);
				break;
			case COMMAND_ERROR :
				commandObject = initErrorCommand(parsedUserInput);
				break;
			case COMMAND_FILEPATH :
				commandObject = initFilePathCommand(parsedUserInput);
		}
	return commandObject;
	}

	private String determineCommandType(String commandGiven) {
		String commandString = "";
		if (Arrays.asList(addKeywords).contains(commandGiven)){
			commandString =  COMMAND_ADD;
		} else if (Arrays.asList(editKeywords).contains(commandGiven)) {
			commandString = COMMAND_EDIT;
		} else if (Arrays.asList(sortKeywords).contains(commandGiven)) {
			commandString = COMMAND_SORT;
		} else if (commandGiven.contains(COMMAND_SEARCH)) {
			commandString = COMMAND_SEARCH;
		} else if (commandGiven.contains(COMMAND_ERROR)) {
			commandString = COMMAND_ERROR;
		} else if (Arrays.asList(viewKeywords).contains(commandGiven)) {
			commandString = COMMAND_VIEW;
		} else if (commandGiven.contains(COMMAND_EXIT)) {
			commandString = COMMAND_EXIT;
		} else if (commandGiven.contains(COMMAND_UNDO)) {
			commandString = COMMAND_UNDO;
		} else if (commandGiven.contains(COMMAND_REDO)) {
			commandString = COMMAND_REDO;
		} else if (commandGiven.contains(COMMAND_FILEPATH)) {
			commandString = COMMAND_FILEPATH;
		}
		return commandString;
	}
	
	private Command initFilePathCommand(ArrayList<String> parsedUserInput) {
		Command filePathCommandObject = new FilePathCommand(Command.Type.FILEPATH, storageComponent);
		filePathCommandObject.setFilePath(parsedUserInput.get(1));
		return filePathCommandObject;
	}
	
	private Command initErrorCommand(ArrayList<String> parsedUserInput) {
		ErrorCommand errorCommandObject = new ErrorCommand(Command.Type.ERROR);
		errorCommandObject.setCommandField(parsedUserInput.get(0));
		errorCommandObject.setErrorMessage(parsedUserInput.get(1));
		return errorCommandObject;
	}

	private Command initViewCommand(ArrayList<String> parsedUserInput) {
		ViewCommand viewCommandObject = new ViewCommand(Command.Type.VIEW, storageComponent);
		viewCommandObject.setCommandField(parsedUserInput.get(0));
		return viewCommandObject;
	}
	
	private Command initRedoCommand(ArrayList<String> parsedUserInput) {
		Command redoCommandObject = new Command(Command.Type.REDO);
		redoCommandObject.setCommandField(parsedUserInput.get(0));
		return redoCommandObject;
	}

	private Command initUndoCommand(ArrayList<String> parsedUserInput) {
		Command undoCommandObject = new Command(Command.Type.UNDO);
		undoCommandObject.setCommandField(parsedUserInput.get(0));
		return undoCommandObject;
	}
	
	private Command initExitCommand(ArrayList<String> parsedUserInput) {
		Command exitCommandObject = new Command(Command.Type.EXIT);
		exitCommandObject.setCommandField(parsedUserInput.get(0));
		return exitCommandObject;
	}

	private Command initSearchCommand(ArrayList<String> parsedUserInput) {
		SearchCommand searchCommandObject = new SearchCommand(Command.Type.SEARCH, storageComponent);
		searchCommandObject.setCommandField(parsedUserInput.get(0));
		searchCommandObject.setKeywords(parsedUserInput.get(1));
		return searchCommandObject;
	}

	private Command initSortCommand(ArrayList<String> parsedUserInput) {
		SortCommand sortCommandObject = new SortCommand(Command.Type.SORT, storageComponent);
		sortCommandObject.setSortField(parsedUserInput.get(0));
		return sortCommandObject;
	}
	
	private void setCommand(Command editCommandObject, String description,
			String priority, String reminder, String startDateAndTime, String endDateAndTime, 
			String recurrence, String newName) {
		
		editCommandObject.setDescription(description);
		editCommandObject.setPriority(priority);
		editCommandObject.setEndDateAndTime(startDateAndTime);
		editCommandObject.setEndDateAndTime(endDateAndTime);
		editCommandObject.setReminder(reminder);
		editCommandObject.setRecurrence(recurrence);
		editCommandObject.setNewName(newName);	
	}

	private Command initAddCommand(ArrayList<String> parsedUserInput) {
		int inputLength = parsedUserInput.size();
		AddCommand addCommandObject = new AddCommand(Command.Type.ADD, 
				storageComponent, historySubComponent);
		addCommandObject.setCommandField(parsedUserInput.get(0));
		addCommandObject.setTaskName(parsedUserInput.get(1));
		
		setCommand(addCommandObject, parsedUserInput.get(2),
				parsedUserInput.get(inputLength-3), parsedUserInput.get(inputLength-2), 
				EMPTY, EMPTY, parsedUserInput.get(inputLength-1), EMPTY);

		switch (parsedUserInput.get(0)){
			case (COMMAND_ADD_TODO):
				addCommandObject.setEndDateAndTime(parsedUserInput.get(3));
				break;
			case (COMMAND_ADD_EVENT):
				addCommandObject.setStartDateAndTime(parsedUserInput.get(3));
				addCommandObject.setEndDateAndTime(parsedUserInput.get(4));
				break;
		}
		return addCommandObject;
	}

	private Command initEditCommand(ArrayList<String> parsedUserInput) {
		EditCommand editCommandObject = new EditCommand(Command.Type.EDIT, 
				storageComponent, historySubComponent);
		
		editCommandObject.setCommandField(parsedUserInput.get(0));
		if(parsedUserInput.size() > 1) {
			editCommandObject.setTaskName(parsedUserInput.get(1));
		}

		switch (parsedUserInput.get(0)) {
			case (COMMAND_SET_FLOAT) :
				setCommand(editCommandObject, parsedUserInput.get(2),
						parsedUserInput.get(3), parsedUserInput.get(4), EMPTY, EMPTY, 
						parsedUserInput.get(5), parsedUserInput.get(6));
				break;
			case (COMMAND_SET_TODO) :
				setCommand(editCommandObject, parsedUserInput.get(2),
						parsedUserInput.get(4), parsedUserInput.get(5), EMPTY, 
						parsedUserInput.get(3), parsedUserInput.get(6), parsedUserInput.get(7));
				break;
			case (COMMAND_SET_EVENT) :
				setCommand(editCommandObject, parsedUserInput.get(2),
						parsedUserInput.get(5), parsedUserInput.get(6), 
						parsedUserInput.get(3), parsedUserInput.get(4), 
						parsedUserInput.get(7), parsedUserInput.get(8));
				break;
			case (COMMAND_DEADLINE) :
				editCommandObject.setEndDateAndTime(parsedUserInput.get(2));
				break;
			case (COMMAND_EVENT) :
				editCommandObject.setStartDateAndTime(parsedUserInput.get(2));
				editCommandObject.setEndDateAndTime(parsedUserInput.get(3));
				break;
			case (COMMAND_DESCRIPTION) :
				editCommandObject.setDescription(parsedUserInput.get(2));
				break;
			case (COMMAND_REMINDER) :
				editCommandObject.setReminder(parsedUserInput.get(2));
				break;
			case (COMMAND_PRIORITY) :
				editCommandObject.setPriority(parsedUserInput.get(2));
				break;
			case (COMMAND_RENAME) :
				editCommandObject.setNewName(parsedUserInput.get(2));
				break;
			case(COMMAND_RESET) :
				editCommandObject.setResetField(parsedUserInput.get(2));
				break;
			case (COMMAND_RECUR) :
				editCommandObject.setRecurrence(parsedUserInput.get(2));
				break;
		}
		return editCommandObject;
	}

}
```
###### src\main\java\backend\Logic\LogicFacade.java
``` java
package main.java.backend.Logic;

import java.util.ArrayList;
import java.util.EmptyStackException;
import java.util.Stack;
import java.util.logging.Logger;

import main.java.backend.Parser.Parser;
import main.java.backend.Storage.Storage;
import main.java.backend.Storage.StorageFacade;
import main.java.backend.Storage.Task.Task;
import main.java.backend.Util.LoggerGlobal;

public class LogicFacade {
	
	private static final String EXECUTION_COMMAND_UNSUCCESSFUL = "Invalid Command. Please try again.";
	private static final String LOGGER_PARSED_INPUT = "Parsed User Input";
	
	private static Logger logicFacadeLogger = LoggerGlobal.getLogger();	
	
	private static LogicFacade logicFacade;
	
	private Storage storageComponent;
	private Observer getterSubComponent;
	private History historySubComponent;
	private Parser parserComponent;
	private LogicCommandHandler logicCommandHandler;
	
	private Stack<Command> historyStack;
	private Stack<Command> futureStack;
	private Stack<Command> searchStack;
	private ArrayList<Task> currentState;
	
	private LogicFacade() {
		
		storageComponent = new StorageFacade();
		historySubComponent = History.getInstance();
		logicCommandHandler = LogicCommandHandler.getInstance(storageComponent, historySubComponent);
		storageComponent.init();
		parserComponent = new Parser();
		getterSubComponent = Observer.getInstance(storageComponent);
		historyStack = new Stack<Command>();
		futureStack = new Stack<Command>();
		searchStack = new Stack<Command>();
		currentState = storageComponent.load();
		historySubComponent.push(currentState);
		LoggerGlobal.initLogger();
	}
	
	public static LogicFacade getInstance() {
		
		if (logicFacade == null) {
			logicFacade = new LogicFacade();
		}
		return logicFacade;
	}
	
	public String execute(String userInput) {
		
		try {
			ArrayList<String> parsedUserInput = parserComponent.parseInput(userInput);
			logicFacadeLogger.info(LOGGER_PARSED_INPUT + parsedUserInput);
			Command commandObject = logicCommandHandler.parse(parsedUserInput);
			String feedbackString = "";
			
			switch (commandObject.getType()) {
				case UNDO :
					Command undoableCommand = historyStack.pop();
					feedbackString = undoableCommand.undo();
					futureStack.push(undoableCommand);
					break;
				case REDO :
					feedbackString = futureStack.peek().redo();
					historyStack.push(futureStack.pop());
					break;
				case VIEW :
					feedbackString = commandObject.getCommandField();
					break;
				case ERROR :
					feedbackString = commandObject.getErrorMessage();
					break;
				case SEARCH :
					feedbackString = commandObject.execute();
					searchStack.push(commandObject);
					break;
				case FILEPATH :
					feedbackString = commandObject.execute();
					break;
				case EXIT :
					exit();
				default :
					feedbackString = commandObject.execute();
					historyStack.push(commandObject);
					futureStack = new Stack<Command> ();
			}
			
			getterSubComponent.updateIndex();
			return feedbackString;
		} catch (NullPointerException | EmptyStackException e) {
			return EXECUTION_COMMAND_UNSUCCESSFUL;
		}
	}
	
	private void exit() {
		historySubComponent.exit();
		logicCommandHandler.exit();
		System.exit(0);
	}
	
	public ArrayList<Task> retrieveSearchData() {
		
		if(!searchStack.isEmpty()) {
			searchStack.peek().execute();
			ArrayList<Task> searchResults = searchStack.peek().getSearchResults();
			getterSubComponent.updateSearchResultsList(searchResults);	
		}
		
		return getterSubComponent.getSearchResultsList();
	}
	
	public ArrayList<Task> retrieveTaskData(String dataType) {
		return getterSubComponent.retrieveTaskData(dataType);
	}
}
```
###### src\main\java\backend\Logic\Observer.java
``` java
	public static Observer getInstance(Storage storageComponent) {
		
		if (logicGetterObject == null) {
			logicGetterObject = new Observer(storageComponent);
		}
		return logicGetterObject;
	}

```
###### src\main\java\backend\Logic\Observer.java
``` java
	private Observer(Storage storage) {
		this.storageComponent = storage;
		this.searchResults = new ArrayList<Task>();
		this.taskList = storage.load();
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private void retrieveAllData(){
		getTasks = retrieveTaskData(RETRIEVE_UPCOMING_TODO);
		assert getTasks != null;
		getEvents = retrieveTaskData(RETRIEVE_UPCOMING_EVENTS);
		assert getEvents != null;
		getOverdue = retrieveTaskData(RETRIEVE_OVERDUE);
		assert getOverdue != null;
		getFloat = retrieveTaskData(RETRIEVE_FLOAT);
		assert getFloat != null;
		retrieveTodays();
		retrieveCompletes();
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private void retrieveCompletes(){
		getCompletedTasks = retrieveTaskData(RETRIEVE_COMPLETED_TODO);
		getCompletedEvents = retrieveTaskData(RETRIEVE_PAST_EVENTS);
		getCompletedFloat = retrieveTaskData(RETRIEVE_COMPLETED_FLOAT);
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private void retrieveTodays(){
		getTodayTasks = retrieveTaskData(RETRIEVE_TODAY_TODO);
		getTodayEvents = retrieveTaskData(RETRIEVE_TODAY_EVENTS);
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	private void setIndex(ArrayList<Task> list, int taskIndex) {
		
		taskList = storageComponent.load();
		for (Task task : list) { 
			task.setIndex(++taskIndex);
			taskList.set(task.getTaskId(), task);	
		}
		
		storageComponent.save(taskList);
	}

```
###### src\main\java\backend\Logic\Observer.java
``` java
	public ArrayList<Task> getSearchResultsList() {
		return this.searchResults;
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	public void updateSearchResultsList(ArrayList<Task> searchList) {
		this.searchResults = searchList;
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	public ArrayList<Task> retrieveTaskData(String dataType) {
		
		ArrayList<Task> data = new ArrayList<Task>();
		
		switch(dataType) {
			case (RETRIEVE_TODAY) :
				data = getAllToday();
				break;
			case (RETRIEVE_TODAY_TODO) :
				data = getTodayToDos();
				break;
			case (RETRIEVE_TODAY_EVENTS) :
				data = getTodayEvents();
				break;
			case (RETRIEVE_OVERDUE) :
				data = getAllOverdue();
				break;
			case (RETRIEVE_PAST_EVENTS) :
				data = getPastEvents();
				break;
			case (RETRIEVE_TODO) :
				data = getToDos();
				break;
			case (RETRIEVE_FLOAT) :
				data = getUnDoneFloatingTasks();
				break;
			case (RETRIEVE_EVENTS) :
				data = getEvents();
				break;
			case (RETRIEVE_COMPLETED_FLOAT) :
				data = getCompletedFloats();
				break;
			case (RETRIEVE_COMPLETED_TODO) :
				data = getCompletedToDos();
				break;
			case (RETRIEVE_UPCOMING_TODO) :
				data = getUpcomingToDos();
				break;
			case (RETRIEVE_UPCOMING_EVENTS) :
				data = getUpcomingEvents();
				break;
			case (RETRIEVE_REMINDER) :
				data = getAllReminder();
				break;
		}		
		
		if(!taskList.isEmpty() && !taskList.get(0).isSorted()) {
			Collections.sort(data);
		}
		return data;
	}
	
```
###### src\main\java\backend\Logic\Observer.java
``` java
	public void updateIndex() {

		resetRecurring();
		retrieveAllData();
		int taskSize = getTasks.size(), completedTaskSizeventSize = getEvents.size(), 
				overdueSize = getOverdue.size(), floatSize = getFloat.size(), 
				completedTaskSize = getCompletedTasks.size(), completedEventSize = getCompletedEvents.size();

		setIndex(getTasks, 0);
		setIndex(getEvents, taskSize);
		setIndex(getOverdue, taskSize + completedTaskSizeventSize);
		setIndex(getFloat, taskSize + completedTaskSizeventSize + overdueSize);
		setIndex(getCompletedTasks, taskSize + completedTaskSizeventSize + overdueSize + floatSize);
		setIndex(getCompletedEvents, taskSize + completedTaskSizeventSize + overdueSize 
				+ floatSize + completedTaskSize);
		setIndex(getCompletedFloat, taskSize + completedTaskSizeventSize + overdueSize 
				+ floatSize + completedTaskSize + completedEventSize);
	}
	
}
```
###### src\main\java\backend\Logic\SearchCommand.java
``` java
	public SearchCommand(Type typeInput, Storage storage) {
		super(typeInput);
		storageComponent = storage;
	}
	
```
###### src\main\java\backend\Logic\SearchCommand.java
``` java
	private String feedback(ArrayList<Task> searchResults) {
		
		if (searchResults.isEmpty()) {
			return EXECUTION_SEARCH_UNSUCCESSFUL;
		} else {
			return EXECUTION_SEARCH_SUCCESSFUL;
		}
	}
	
```
###### src\main\java\backend\Logic\SearchCommand.java
``` java
	public ArrayList<Task> getSearchResults() {
		return this.searchResults;
	}
	
```
###### src\main\java\backend\Logic\SortCommand.java
``` java
	public SortCommand(Type typeInput, Storage storage) {
		super(typeInput);
		storageComponent = storage;
		currentState = storageComponent.load();
	}

```
###### src\main\java\backend\Logic\SortCommand.java
``` java
	public void setSortField(String input) {
		this.sortField = input;
	}
	
```
###### src\main\java\backend\Logic\SortCommand.java
``` java
	public String execute() {
		ArrayList<Task> sortedEvent = sort(sortField, currentState);
		storageComponent.save(sortedEvent);
		return EXECUTION_SORT_SUCCESSFUL;
	}
	
```
###### src\main\java\backend\Logic\ViewCommand.java
``` java
package main.java.backend.Logic;

import main.java.backend.Storage.Storage;

public class ViewCommand extends Command {
	
	public ViewCommand(Type typeInput, Storage storage) {
		super(typeInput);
	}
}
```
###### src\main\java\backend\Storage\StorageFilePath.java
``` java
	/**
	 * Transfers all data from current file to new file.
	 * 
	 * @param oldFilePath		File path of current file
	 * @param newFilePath		File path of new file
	 */
	private boolean dataTransfer(String oldFilePath, String newFilePath) {
	
		byte[] buffer = new byte[10000];
		try {
			FileInputStream fileInput = new FileInputStream(oldFilePath);
			BufferedInputStream bufferedInput = new BufferedInputStream(fileInput);
			FileOutputStream fileOutput = new FileOutputStream(newFilePath);
			BufferedOutputStream bufferedOutput = new BufferedOutputStream(fileOutput);
			while(true) {
				int length = fileInput.read(buffer);
				if(length == -1) {
					break;
				} else {
					bufferedOutput.write(buffer);
					bufferedOutput.flush();
				}	
			}
			File oldFile = new File(oldFilePath);
			bufferedInput.close();
			bufferedOutput.close();
			oldFile.delete();
			return true;
		} catch (IOException e) {
			System.out.println(ERROR_TRANSFER_DATA);
			return false;
		}
	}
	
```
###### src\main\java\backend\Util\LoggerGlobal.java
``` java
package main.java.backend.Util;

import java.io.IOException;
import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

public class LoggerGlobal {
	
	private static final String LOGGER_INIT_UNSUCCESSFUL = "Logger failed to initialise.";
	private static final String LOGGER_FILE_NAME = "TankTaskLog.log";
	private static final int LOGGER_LIMIT = 1000000000;
	private static final int LOGGER_COUNT = 10;
	
	private static final Logger logger = Logger.getGlobal();
	private static FileHandler logHandler;
	
	public LoggerGlobal() {
		
	}
	
	public static void initLogger() {
		
		try {
			logHandler = new FileHandler(LOGGER_FILE_NAME, LOGGER_LIMIT, LOGGER_COUNT, true);
			logHandler.setFormatter(new SimpleFormatter());
			logger.addHandler(logHandler);
			logger.setUseParentHandlers(false);

		} catch (SecurityException | IOException e) {
			System.out.println(LOGGER_INIT_UNSUCCESSFUL);
		}
	}

	public static Logger getLogger() {
		return logger;
	}
	
}
```
###### src\test\main\java\backend\Logic\LogicUnitTest.java
``` java
package main.java.backend.Logic;

import static org.junit.Assert.*;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

public class LogicUnitTest {
	
	private static LogicFacade testLogicFacade; 

	/**
	 * @throws java.lang.Exception
	 */
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		testLogicFacade = LogicFacade.getInstance();
	}
	

	/**
	 * @throws java.lang.Exception
	 */
	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		testLogicFacade.execute("deleteAll");
	}

	/**
	 * @throws java.lang.Exception
	 */
	@Before
	public void setUp() throws Exception {
	}

	/**
	 * @throws java.lang.Exception
	 */
	@After
	public void tearDown() throws Exception {
		
	}
	
//	@Test
//	public void testExecuteUndoWhenCommandStackEmpty() {
//		String result = testLogicFacade.execute("undo");
//		assertEquals(result, "Invalid command. Please try again.");
//	}

	@Test
	public void testExecuteAdd() {
		String result = testLogicFacade.execute("add Call beloved girlfriend");
		assertEquals(result, "Task Call beloved girlfriend has been added");
	}
	
	@Test
	public void testExecuteEdit() {
		String result = testLogicFacade.execute("add Plan a date with beloved girlfriend");
		result = testLogicFacade.execute("1 priority 5");
		assertEquals(result, "Task 1 has been set to priority 5");
	}
	
	@Test
	public void testExecuteUndo() {
		String result = testLogicFacade.execute("add find beloved girlfriend");
		result = testLogicFacade.execute("undo");
		assertEquals(result, "Undo successfully.");
	}
	
	@Test
	public void testExecuteRedo() {
		String result = testLogicFacade.execute("add find beloved girlfriend");
		result = testLogicFacade.execute("undo");
		result = testLogicFacade.execute("redo");
		assertEquals(result, "Redo successfully.");
	}
	
	@Test
	public void testConvertFromFloatToToDo() {
		String result = testLogicFacade.execute("add get flowers beloved girlfriend");
		result = testLogicFacade.execute("1 deadline 30 oct");
		assertEquals(result, "Task 1 deadline has been set to Sun, 30 Oct 16, 11:59pm" );
	}
	
	@Test
	public void testConvertFromFloatToEvents() {
		String result = testLogicFacade.execute("add go on a date beloved girlfriend");
		result = testLogicFacade.execute("1 event 24 dec 12pm to 25 dec");
		assertEquals(result, "Event 1 has been setted to Thu, 24 Dec 15, 12pm till Fri, 25 Dec 15, 9pm");
	}
	
	@Test
	public void testSetDescription() {
		String result = testLogicFacade.execute("add get flowers beloved girlfriend");
		result = testLogicFacade.execute("1 description Get flowers from shop A");
		assertEquals(result, "InvalidDateError: 'shop A' is not an acceptable date format");
	}
	
	@Test
	public void testSetReminder() {
		String result = testLogicFacade.execute("add get flowers beloved girlfriend");
		result = testLogicFacade.execute("1 reminder 23 dec 10am");
		assertEquals(result, "Reminder for Task 1 has been set to be at Wed, 23 Dec 15, 10am");
	}
	
	//Tried to do equivalence partitioning here. Valid value is between
	//1- 5. So checking 0 which is below the min and 10 which is above
	//the max can already check for invalid inputs. Also applies for
	//Boundary Value Analysis
	@Test
	public void testSetPriorityValid() {
		String result = testLogicFacade.execute("add Plan a date with beloved girlfriend");
		result = testLogicFacade.execute("1 priority 1");
		assertEquals(result,"Task 1 has been set to priority 1");
	}
	
	@Test
	public void testSetPriorityInvalidLargerThanRange() {
		String result = testLogicFacade.execute("add Plan a date with beloved girlfriend");
		result = testLogicFacade.execute("1 priority 10");
		assertEquals(result, "InvalidPriorityError: '10' is not between 1 to 5");
	}
	
	@Test
	public void testSetPriorityInvalidSmallerThanRange() {
		String result = testLogicFacade.execute("add Plan a date with beloved girlfriend");
		result = testLogicFacade.execute("1 priority 0");
		assertEquals(result, "InvalidPriorityError: '0' is not between 1 to 5");
	}
	
	@Test
	public void testDelete() {
		String result = testLogicFacade.execute("add Impromptu Meeting with Boss");
		result = testLogicFacade.execute("delete 1");
		assertEquals(result, "Task 1 has been deleted");
	}
	
	@Test
	public void testSetMultipleFieldsForTask() {
		String result = testLogicFacade.execute("add Complete Project D Proposal deadline 22 dec");
		result = testLogicFacade.execute("1 priority 5 description Finish Subsections A to D reminder 19 dec");
		assertEquals(result,"Fields have been updated");
	}
	
	@Test
	public void testSearchFound(){
		String result = testLogicFacade.execute("add find beloved girlfriend");
		result = testLogicFacade.execute("add Get something for beloved girlfriend deadline 24 dec");
		result = testLogicFacade.execute("add Go on a date with beloved girlfriend event 24 dec to 25 dec");
		result = testLogicFacade.execute("search beloved girlfriend");
		assertEquals(result,"search");
	}
	
	@Test
	public void testSearchNotFound() {
		String result = testLogicFacade.execute("search picnic with beloved girlfriend");
		assertEquals(result,"Input not found");
	}
	
	@Test
	public void testDoneFloat() {
		String result = testLogicFacade.execute("add Plan a date with beloved girlfriend");
		result = testLogicFacade.execute("done 1");
		assertEquals(result, "Task 1 is completed");
	}
	
	@Test
	public void testDoneEvent() {
		String result = testLogicFacade.execute("add Go on a date with beloved girlfriend event 24 dec to 25 dec");
		result = testLogicFacade.execute("done 1");
		assertEquals(result, "Task 1 is completed");
	}
	
	@Test
	public void testDoneToDo() {
		String result = testLogicFacade.execute("add Get something for beloved girlfriend deadline 24 dec");
		result = testLogicFacade.execute("done 1");
		assertEquals(result, "Task 1 is completed");
	}
	
	@Test
	public void testUndoneFloat() {
		String result = testLogicFacade.execute("add Plan a date with beloved girlfriend");
		result = testLogicFacade.execute("done 1");
		result = testLogicFacade.execute("undone 1");
		assertEquals(result, "Task 1 is not completed");
	}
	
	@Test
	public void testUndoneEvent() {
		String result = testLogicFacade.execute("add Meeting with Supervisor B event 22 dec 10am to 22 dec 10am");
		result = testLogicFacade.execute("done 1");
		result = testLogicFacade.execute("undone 1");
		assertEquals(result, "Task 1 is not completed");
	}
	
	@Test
	public void testUndoneToDo() {
		String result = testLogicFacade.execute("add Get something for beloved girlfriend deadline 24 dec");
		result = testLogicFacade.execute("done 1");
		result = testLogicFacade.execute("undone 1");
		assertEquals(result, "Task 1 is not completed");
	}
	
	@Test 
	public void testShowFloatLong() {
		String result = testLogicFacade.execute("show Floating");
		assertEquals(result, "showF");
	}
	
	@Test 
	public void testDeleteAll() {
		testLogicFacade.execute("add Float Task A");
		testLogicFacade.execute("add Task B deadline 30 dec");
		testLogicFacade.execute("add Soemthing happening C event 30 dec 10am to 30 dec 12pm");
		String result = testLogicFacade.execute("deleteAll");
		assertEquals(result,"Everything has been deleted");
	}

}
```
###### src\test\main\java\gui\TankTaskSystemTest.java
``` java
package main.java.gui;

import static org.junit.Assert.*;

import java.io.IOException;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

public class TankTaskSystemTest {
	private static GuiController testTankTask = new GuiController();
	private static String result = "";

	/**
	 * @throws java.lang.Exception
	 */
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		testTankTask = new GuiController();
	}
	

	/**
	 * @throws java.lang.Exception
	 */
	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		testTankTask.executeCommand("deleteAll");
	}

	/**
	 * @throws java.lang.Exception
	 */
	@Before
	public void setUp() throws Exception {
		testTankTask.executeCommand("deleteAll");
	}

	/**
	 * @throws java.lang.Exception
	 */
	@After
	public void tearDown() throws Exception {
	}
	
	// ================================================================
    // Input Validation Test
    // ================================================================

	@Test
	public void testInvalidCommandError() {
		testTankTask.executeCommand("add Call beloved girlfriend");
		result = testTankTask.executeCommand("1 5");
		assertEquals(result, "InvalidCommandError: '5' is not recognised as a command");
	}
	
	@Test
	public void testNoCommandError() {
		result = testTankTask.executeCommand("5 ");
		assertEquals(result, "NoCommandError: Please enter a command after the task index '5'");
	}
	
//	@Test
//	public void testDuplicateCommand() {
//		testTankTask.executeCommand("add test to do something from today to tomorrow");
//		result = testTankTask.executeCommand("1 every every week");
//		assertEquals(result, "Task 1 recurring has been set to 1 week");
//	}
	
    // ================================================================
    // Add Operations Test
    // ================================================================
	
	@Test
	public void testAddFloat() {
		result = testTankTask.executeCommand("add Call beloved girlfriend");
		assertEquals(result, "Task Call beloved girlfriend has been added");
	}
	
	@Test
	public void testAddAllCaps() {
		result = testTankTask.executeCommand("ADD TAKE THIS");
		assertEquals(result, "Task TAKE THIS has been added");
	}
	
	@Test
	public void testAddWithOtherCommandsIgnored() {
		result = testTankTask.executeCommand("add Call beloved girlfriend search delete done undone");
		assertEquals(result, "Task Call beloved girlfriend search delete done undone has been added");
	}
	
	@Test
	public void testAddWithOtherCommandsIgnoredTwo() {
		result = testTankTask.executeCommand("add addcat delete search reset sortp exit showf");
		assertEquals(result, "Task addcat delete search reset sortp exit showf has been added");
	}
	
	@Test
	public void testAddWithOtherCommandsIgnoredThree() {
		result = testTankTask.executeCommand("add something delete");
		assertEquals(result, "Task something delete has been added");
	}
	
	@Test
	public void testMultipleAdd() {
		result = testTankTask.executeCommand("add add Call beloved girlfriend");
		assertEquals(result, "Task add Call beloved girlfriend has been added");
	}
	
	@Test
	public void testMultipleAddWithOtherCommands() {
		result = testTankTask.executeCommand("add add Call beloved girlfriend priority 5");
		assertEquals(result, "Task add Call beloved girlfriend has been added");
	}
		
	@Test 
	public void testAddCommandMissingAddError() {
		result = testTankTask.executeCommand("Call beloved girlfriend");
		assertEquals(result, "InvalidWordError: 'Call' is not recognised as a command or index");
	}
	
	@Test
	public void testAddDeadline() {
		result = testTankTask.executeCommand("add Plan to do something deadline december 23");
		assertEquals(result, "Task Plan to do something has been added");
	}
	
	@Test
	public void testAddDeadlineShortForm() {
		result = testTankTask.executeCommand("add Plan to do something by December 23");
		assertEquals(result, "Task Plan to do something has been added");
	}
	
	@Test
	public void testAddDeadlineShortFormTwo() {
		result = testTankTask.executeCommand("add Plan to do something dea next tue");
		assertEquals(result, "Task Plan to do something has been added");
	}
	
	@Test 
	public void testAddOldDeadline() {
		result = testTankTask.executeCommand("add old stuff deadline 24/12/1995");
		assertEquals(result, "Task old stuff has been added");
	}
	
	@Test 
	public void testAddOldDeadlineTwo() {
		result = testTankTask.executeCommand("add old stuff deadline 24 dec 95");
		assertEquals(result, "Task old stuff has been added");
	}
	
	@Test
	public void testMultipleDeadlineError() {
		result = testTankTask.executeCommand("add something deadline today deadline today");
		assertEquals(result, "DuplicateCommandError: Duplicate command 'deadline'");
	}
	
	@Test
	public void testAddEvent() {
		result = testTankTask.executeCommand("add Go on a date with beloved girlfriend event 25/12/15 12:00 to 25/12/15 23:00");
		assertEquals(result, "Task Go on a date with beloved girlfriend has been added");
	}
	
	@Test
	public void testAddEventWithEndTimeEarlierThanStartTime() {
		result = testTankTask.executeCommand("add Go on a date with beloved girlfriend event 25 dec 12:00 to 08:00");
		assertEquals(result, "Task Go on a date with beloved girlfriend has been added");
	}
	
	@Test
	public void testAddEventWithEndTimeEarlierThanStartTimeTwo() {
		result = testTankTask.executeCommand("add Go on a date with beloved girlfriend event 25december 12:30 to 12:10");
		assertEquals(result, "Task Go on a date with beloved girlfriend has been added");
	}
	
	@Test
	public void testAddEventWithEndTimeEarlierThanStartTimeThree() {
		result = testTankTask.executeCommand("add Go on a date with beloved girlfriend event 12:30 25/12/15 to 12:30");
		assertEquals(result, "Task Go on a date with beloved girlfriend has been added");
	}
	
	@Test
	public void testAddEventWithNoEndTime() {
		result = testTankTask.executeCommand("add Go on a date with beloved girlfriend event 25/12/15 12:30 ");
		assertEquals(result, "Task Go on a date with beloved girlfriend has been added");
	}
	
	@Test 
	public void testAddEventWithOnlyStartDay() {
		result = testTankTask.executeCommand("add Celebrate New Year With Beloved Girlfriend event 1Jan");
		assertEquals(result, "Task Celebrate New Year With Beloved Girlfriend has been added");
	}
	
	@Test
	public void testAddEventWithEndDateButNoEndTime() {
		result = testTankTask.executeCommand("add Go on a date with beloved girlfriend event 25/12/15 1230 to 26/12/15 ");
		assertEquals(result, "Task Go on a date with beloved girlfriend has been added");
	}
	
	@Test
	public void testAddEventWithEndDateButNoEndTimeTwo() {
		result = testTankTask.executeCommand("add Go on a date with beloved girlfriend event 25/12/15 1230 to ");
		assertEquals(result, "NoEndDateError: Please enter an end date after the command word 'to'");
	}
	
	@Test
	public void testAddEventWithDateConflictError() {
		result = testTankTask.executeCommand("add something deadline tomorrow from today to tomorrow");
		assertEquals(result, "ConflictingDatesError: Task cannot have both deadline and event date");
	}
	
	@Test
	public void testAddEventShortForm() {
		result = testTankTask.executeCommand("add Go on a date with beloved girlfriend from dec 25 12pm to 25 dec 11pm");
		assertEquals(result, "Task Go on a date with beloved girlfriend has been added");
	}
	
	@Test
	public void testAddToDoAFewDaysLater() {
		result = testTankTask.executeCommand("Add Go on a date with beloved girlfriend by 3 days later");
		assertEquals(result, "Task Go on a date with beloved girlfriend has been added");
	}
	
	@Test
	public void testAddToDoAFewSaturdaysLater() {
		result = testTankTask.executeCommand("Add Help beloved girlfriend clean house by 2 Saturdays later");
		assertEquals(result, "Task Help beloved girlfriend clean house has been added");
	}
	
	@Test
	public void testAddToDoAFewMonthsLater() {
		result = testTankTask.executeCommand("Add Have a dental appointment by 3 months later");
		assertEquals(result, "Task Have a dental appointment has been added");
	}
	
	@Test
	public void testAddToDoFewYearsLater() {
		result = testTankTask.executeCommand("Add Propose to beloved girlfriend by 6 years later");
		assertEquals(result, "Task Propose to beloved girlfriend has been added");
	}
	
	@Test
	public void testAddRecurrenceToDoDay() {
		testTankTask.executeCommand("add Call beloved girlfriend deadline 10pm today");
		result = testTankTask.executeCommand("1 every day");
		assertEquals(result, "Task 1 recurring has been set to 1 day");
	}
	
	@Test
	public void testAddRecurrenceToDoEveryFortyDays() {
		testTankTask.executeCommand("add Cut hair deadline 10pm");
		result = testTankTask.executeCommand("1 every 40 days");
		assertEquals(result, "Task 1 recurring has been set to 40 day");
	}
	
	@Test
	public void testAddRecurrenceToDoDayAnotherWay() {
		testTankTask.executeCommand("add Call beloved girlfriend deadline 10pm");
		result = testTankTask.executeCommand("1 recur day");
		assertEquals(result, "Task 1 recurring has been set to 1 day");
	}
	
	@Test
	public void testAddRecurrenceToDoWeek() {
		testTankTask.executeCommand("add Watch movie with beloved girlfriend from Sunday 6pm to 10pm");
		result = testTankTask.executeCommand("1 every week");
		assertEquals(result, "Task 1 recurring has been set to 1 week");
	}
	
	@Test
	public void testAddRecurrenceToDoEveryTwoWeek() {
		testTankTask.executeCommand("add Clean house from Sunday 6am to 10am");
		result = testTankTask.executeCommand("1 every 2 weeks");
		assertEquals(result, "Task 1 recurring has been set to 2 week");
	}
	
	@Test
	public void testAddRecurrenceToDoWeekAnotherWay() {
		testTankTask.executeCommand("add Watch movie with beloved girlfriend from Sunday 6pm to 10pm");
		result = testTankTask.executeCommand("1 recur week");
		assertEquals(result, "Task 1 recurring has been set to 1 week");
	}
	
	@Test
	public void testAddRecurrenceToDoMonth() {
		testTankTask.executeCommand("add Celebrate Monthsary with beloved girlfriend from 16 nov");
		result = testTankTask.executeCommand("1 every month");
		assertEquals(result, "Task 1 recurring has been set to 1 month");
	}
	
	@Test
	public void testAddRecurrenceFloatingMonthFail() {
		testTankTask.executeCommand("add Celebrate Monthsary with beloved girlfriend 16 nov");
		result = testTankTask.executeCommand("1 every month");
		assertEquals(result, "Unable to recur floating tasks");
	}
	
	@Test
	public void testAddRecurrenceToDoEverySixMonth() {
		testTankTask.executeCommand("add Visit mum's grave to tidy it deadline 22 dec");
		result = testTankTask.executeCommand("1 every 6 months");
		assertEquals(result, "Task 1 recurring has been set to 6 month");
	}
	
	@Test
	public void testAddRecurrenceToDoMonthAnotherWay() {
		testTankTask.executeCommand("add Celebrate Monthsary with beloved girlfriend deadline 16 nov");
		result = testTankTask.executeCommand("1 recur month");
		assertEquals(result, "Task 1 recurring has been set to 1 month");
	}
	
	@Test
	public void testAddRecurrenceToDoYear() {
		testTankTask.executeCommand("add Celebrate Anniversary with beloved girlfriend deadline 16 nov");
		result = testTankTask.executeCommand("1 every year");
		assertEquals(result, "Task 1 recurring has been set to 1 year");
	}
	
	@Test
	public void testAddRecurrenceToDoYearAnotherWay() {
		testTankTask.executeCommand("add Celebrate Anniversary with beloved girlfriend deadline 16 nov");
		result = testTankTask.executeCommand("1 recur year");
		assertEquals(result, "Task 1 recurring has been set to 1 year");
	}
	
	@Test
	public void testAddRecurrenceToDoTwoYears() {
		testTankTask.executeCommand("add Get new laptop deadline 15 nov");
		result = testTankTask.executeCommand("1 every 2 year");
		assertEquals(result, "Task 1 recurring has been set to 2 year");
	}
	
	@Test
	public void testAddRecurrenceToDoTwoYearsWithS() {
		testTankTask.executeCommand("add Get new laptop deadline 15 nov");
		result = testTankTask.executeCommand("1 every 2 years");
		assertEquals(result, "Task 1 recurring has been set to 2 year");
	}
	
	@Test
	public void testAddRecurrenceToDoWithFrequencyError() {
		testTankTask.executeCommand("add Go to bed");
		result = testTankTask.executeCommand("1 every 2am");
		assertEquals(result, "InvalidFrequencyError: Please enter 'day'/'week'/'month'/'year' after 'every' to indicate the frequency");
	}
	
	@Test
	public void testAddRecurrenceEventDay() {
		testTankTask.executeCommand("add Send a Sweet Dreams SMS to beloved girlfriend from 11:55PM to 11:59PM");
		result = testTankTask.executeCommand("1 every day");
		assertEquals(result, "Task 1 recurring has been set to 1 day");
	}
	
	@Test
	public void testAddRecurrenceEventDayWithDuplicate() {
		testTankTask.executeCommand("add Send a Sweet Dreams SMS to beloved girlfriend from 11:55PM to 11:59PM");
		result = testTankTask.executeCommand("1 every day des Must do this every day");
		assertEquals(result, "Fields have been updated");
	}
	
	@Test
	public void testAddRecurrenceEventThreeDay() {
		testTankTask.executeCommand("add Update Supervisor on work progress from wed 9am to 10am");
		result = testTankTask.executeCommand("1 every 3 days");
		assertEquals(result, "Task 1 recurring has been set to 3 day");
	}
	
	@Test
	public void testAddRecurrenceEventWeek() {
		testTankTask.executeCommand("add Have a homecooked dinner with beloved girlfriend from saturday 6pm to 10pm");
		result = testTankTask.executeCommand("1 every week");
		assertEquals(result, "Task 1 recurring has been set to 1 week");
	}
	
	@Test
	public void testAddRecurrenceEventEveryTwoWeek() {
		testTankTask.executeCommand("add Have a team meeting from 0800 to 10");
		result = testTankTask.executeCommand("1 every 2 week");
		assertEquals(result, "Task 1 recurring has been set to 2 week");
	}
	
	@Test
	public void testAddRecurrenceEventMonth() {
		testTankTask.executeCommand("add Have monthsary date with beloved girlfriend from 16/11/15 12:00 to 10:00");
		result = testTankTask.executeCommand("1 every month");
		assertEquals(result,"Task 1 recurring has been set to 1 month");
	}
	
	@Test
	public void testAddRecurrenceEventEveryThreeMonth() {
		testTankTask.executeCommand("add Have team bonding activities from sat 1200 to 1000");
		result = testTankTask.executeCommand("1 every 3 month");
		assertEquals(result,"Task 1 recurring has been set to 3 month");
	}
	
	@Test
	public void testAddRecurrenceEventYear() {
		testTankTask.executeCommand("add Celebrate Anniversary with beloved girlfriend from 16-11-15 12.00 to 22.00");
		result = testTankTask.executeCommand("1 every year");
		assertEquals(result,"Task 1 recurring has been set to 1 year");
	}
	
	@Test
	public void testAddRecurrenceEventEveryFiveYear() {
		testTankTask.executeCommand("add Celebrate Anniversary with beloved girlfriend from 16/11 12pm to 10pm");
		result = testTankTask.executeCommand("1 every 5 years");
		assertEquals(result,"Task 1 recurring has been set to 5 year");
	}
	
	@Test
	public void testAddRecurrenceEventEveryFiveYearWithExtraCharacters() {
		testTankTask.executeCommand("add Celebrate Anniversary with beloved girlfriend from 16/11 12pm to 10pm");
		result = testTankTask.executeCommand("1 every 5 years aaaaaa");
		assertEquals(result,"Task 1 recurring has been set to 5 year");
	}
	
	@Test
	public void testAddRecurrenceFloatError() {
		result = testTankTask.executeCommand("add something else every week");
		assertEquals(result,"NoDateForRecurrenceError: Cannot make floating task recur. Please set a deadline or start date for the task");
	}
	
	@Test
	public void testAddUndo() {
		testTankTask.executeCommand("add find beloved girlfriend");
		result = testTankTask.executeCommand("undo");
		assertEquals(result, "Undo successfully.");
	}
	
	@Test
	public void testAddRedo() {
		testTankTask.executeCommand("add find beloved girlfriend");
		testTankTask.executeCommand("undo");
		result = testTankTask.executeCommand("redo");
		assertEquals(result, "Redo successfully.");
	}
	
	// ================================================================
    // Edit Operations Test
    // ================================================================
	
	@Test
	public void testEditPriority() {
		testTankTask.executeCommand("add Plan a date with beloved girlfriend");
		result = testTankTask.executeCommand("1 priority 5");
		assertEquals(result, "Task 1 has been set to priority 5");
	}
	
	@Test
	public void testSetPriorityInvalidLargerThanRange() {
		testTankTask.executeCommand("add Plan a date with beloved girlfriend");
		result = testTankTask.executeCommand("1 priority 10");
		assertEquals(result, "InvalidPriorityError: '10' is not between 1 to 5");
	}
	
	@Test
	public void testSetPriorityInvalidSmallerThanRange() {
		testTankTask.executeCommand("add Plan a date with beloved girlfriend");
		result = testTankTask.executeCommand("1 priority 0");
		assertEquals(result, "InvalidPriorityError: '0' is not between 1 to 5");
	}
	
	@Test 
	public void testSetPriorityMissingPriorityValue() {
		testTankTask.executeCommand("add Plan a date with beloved girlfriend");
		String result = testTankTask.executeCommand("1 priority");
		assertEquals(result, "EmptyFieldError: Please enter content for the command 'priority'");
	}
	
	@Test
	public void testConvertFromFloatToToDo() {
		testTankTask.executeCommand("add get flowers beloved girlfriend");
		result = testTankTask.executeCommand("1 deadline 30 oct");
		assertEquals(result, "Task 1 deadline has been set to Sun, 30 Oct 16, 11:59pm");
	}
	
	@Test
	public void testConvertFromFloatToEvents() {
		testTankTask.executeCommand("add go on a date beloved girlfriend");
		result = testTankTask.executeCommand("1 event 24 dec 12pm to 25 dec");
		assertEquals(result, "Event 1 has been setted to Thu, 24 Dec 15, 12pm till Fri, 25 Dec 15, 9pm");
	}
	
	@Test
	public void testSetDescription() {
		testTankTask.executeCommand("add get flowers beloved girlfriend");
		result = testTankTask.executeCommand("1 description \"Get flowers from shop A\"");
		assertEquals(result, "Description for task 1 has been set");
	}
	
	@Test
	public void testSetDescriptionDuplicates() {
		testTankTask.executeCommand("add get flowers beloved girlfriend");
		result = testTankTask.executeCommand("1 description Hello this is a test description");
		assertEquals(result, "Description for task 1 has been set");
	}
	
	@Test
	public void testSetReminder() {
		testTankTask.executeCommand("add get flowers beloved girlfriend");
		result = testTankTask.executeCommand("1 reminder 23 dec 8am");
		assertEquals(result, "Reminder for Task 1 has been set to be at Wed, 23 Dec 15, 8am");
	}
	
	@Test
	public void testSetReminderInvalidTime() {
		testTankTask.executeCommand("add get flowers beloved girlfriend");
		result = testTankTask.executeCommand("1 reminder 23 dec 40am");
		assertEquals(result, "InvalidTimeError: '40am' is not an acceptable time format");
	}
	
	@Test
	public void testSetReminderInvalidDate() {
		testTankTask.executeCommand("add get flowers beloved girlfriend");
		result = testTankTask.executeCommand("1 reminder 3tevsv");
		assertEquals(result, "InvalidDateError: '3tevsv' is not an acceptable date format");
	}
	
	@Test
	public void testSetReminderInvalidDate2() {
		testTankTask.executeCommand("add get flowers beloved girlfriend");
		result = testTankTask.executeCommand("1 reminder 32 dec 10am");
		assertEquals(result, "InvalidDayOfMonthError: The date '32 dec' does not exist "
				+ "(December only has 31 days!)");
	}
	
	@Test
	public void testDelete() {
		testTankTask.executeCommand("add Impromptu Meeting with Boss");
		result = testTankTask.executeCommand("delete 1");
		assertEquals(result, "Task 1 has been deleted");
	}
	
	@Test
	public void testDeleteWithExtraThingsIgnored() {
		testTankTask.executeCommand("add Impromptu Meeting with Boss");
		result = testTankTask.executeCommand("delete 1 extra things here");
		assertEquals(result, "Task 1 has been deleted");
	}
	
	@Test
	public void testDeleteFail() {
		testTankTask.executeCommand("add Impromptu Meeting with Boss");
		result = testTankTask.executeCommand("delete ");
		assertEquals(result, "EmptyFieldError: Please enter content for the command 'delete'");
	}
	
	@Test 
	public void testDeleteAll() {
		testTankTask.executeCommand("add Float Task A");
		testTankTask.executeCommand("add Task B deadline 30 dec");
		testTankTask.executeCommand("add Soemthing happening C event 30 dec 10am to 30 dec 12pm");
		String result = testTankTask.executeCommand("deleteAll");
		assertEquals(result,"Everything has been deleted");
	}
	
	@Test
	public void testRename() {
		testTankTask.executeCommand("add I love my girlfriend");
		result = testTankTask.executeCommand("1 rename I love my CUTE girlfriend! Haha :D");
		assertEquals(result,"Task 1 has been renamed to I love my CUTE girlfriend! Haha :D");
	}
	
	@Test 
	public void testEditUndo() {
		testTankTask.executeCommand("add I love my cute girlfriend pri 5");
		testTankTask.executeCommand("1 pri 1");
		result = testTankTask.executeCommand("undo");
		assertEquals(result, "Undo successfully.");
	}
	
	@Test 
	public void testEditRedoSuccessful() {
		testTankTask.executeCommand("add I love my cute girlfriend pri 1");
		testTankTask.executeCommand("1 pri 5");
		testTankTask.executeCommand("undo");
		result = testTankTask.executeCommand("redo");
		assertEquals(result, "Redo successfully.");
	}
	
	@Test 
	public void testEditRedoFail() {
		testTankTask.executeCommand("add I love my cute girlfriend pri 1");
		testTankTask.executeCommand("1 pri 5");
		result = testTankTask.executeCommand("redo");
		assertEquals(result, "Invalid Command. Please try again.");
	}
	
	@Test
	public void testSetMultipleFieldsForTask() {
		testTankTask.executeCommand("add Backup Terminal ");
		result = testTankTask.executeCommand("1 priority 5 description Finish "
				+ "backing up all files reminder 19 dec every day deadline 22 dec "
				+ "rename Backup Terminal and Mobile Interface");
		assertEquals(result, "Fields have been updated");
	}
	
	@Test
	public void testSetMultipleFieldsForTaskWithErrors() {
		testTankTask.executeCommand("add Complete Project D Proposal");
		result = testTankTask.executeCommand("1 priority description Finish "
				+ "Subsections A to D reminder 19 dec deadline 22 dec "
				+ "rename Complete Project F Proposal");
		assertEquals(result, "EmptyFieldError: Please enter content for the command 'priority'");
	}
	
	@Test 
	public void testSetMultipleFieldsForEvents() {
		testTankTask.executeCommand("add Go on date with girlfriend");
		result = testTankTask.executeCommand("1 rename Go on a date with beloved girlfriend "
				+ "des Take her for ice skating priority 5 "
				+ "from sunday 2pm to 10pm reminder sunday 8am every month");
		assertEquals(result, "Fields have been updated");
	}
	
	@Test 
	public void testSetMultipleFieldsForEventsWithErrors() {
		testTankTask.executeCommand("add Go on date with girlfriend");
		result = testTankTask.executeCommand("1 rename Go on a date with beloved girlfriend "
				+ " des \"Take her to ice skating\" priority  "
				+ "from sunday 2pm to 10pm reminder sunday 8am");
		assertEquals(result, "EmptyFieldError: Please enter content for the command 'priority'");
	}
	
	@Test
	public void testSetMultipleFieldsForFloats() {
		testTankTask.executeCommand("add Think of what to get for beloved girlfriend's present");
		result = testTankTask.executeCommand("1 pri 5 description Seriously how to make her happier than what she already is? "
				+ "rename Think of how to make cute beloved girlfriend happy reminder sunday 12pm");
		assertEquals(result, "Fields have been updated");
	}
	
	@Test 
	public void testResetPriority() {
		testTankTask.executeCommand("add testReset pri 1");
		result = testTankTask.executeCommand("1 reset priority");
		assertEquals(result, "Field priority has been reset");
	}
	
	@Test 
	public void testResetDescription() {
		testTankTask.executeCommand("add testDescription des \"testing the reset\"");
		result = testTankTask.executeCommand("1 reset description");
		assertEquals(result, "Field description has been reset");
	}
	
	@Test
	public void testResetReminder() {
		testTankTask.executeCommand("add testReminder reminder tmr 9am");
		result = testTankTask.executeCommand("1 reset reminder");
		assertEquals(result, "Field reminder has been reset");
	}
	
	@Test
	public void testResetDeadline() {
		testTankTask.executeCommand("add testDeadline by tomorrow");
		result = testTankTask.executeCommand("1 reset date");
		assertEquals(result, "Field date has been reset");
	}
	
	@Test
	public void testResetEvent() {
		testTankTask.executeCommand("add testEvent from today to tomorrow");
		result = testTankTask.executeCommand("1 reset date");
		assertEquals(result, "Field date has been reset");
	}
	
	@Test
	public void testResetAll() {
		testTankTask.executeCommand("add testEvent from sat 5pm to 7pm"
				+ "des testing method pri 3 reminder tomorrow");
		result = testTankTask.executeCommand("1 reset all");
		assertEquals(result, "Field all has been reset");
	}
	
	@Test
	public void testResetWrongField() {
		testTankTask.executeCommand("add testEvent from sat 5pm to 7pm"
				+ "des testing method pri 3 reminder tomorrow");
		result = testTankTask.executeCommand("1 reset anyhow");
		assertEquals(result, "InvalidResetError: 'anyhow' is not a field that can be reset");
	}
	
	@Test
	public void testDoneFloat() {
		testTankTask.executeCommand("add Plan a date with beloved girlfriend");
		result = testTankTask.executeCommand("done 1");
		assertEquals(result, "Task 1 is completed");
	}
	
	@Test
	public void testDoneFloatAnotherWay() {
		testTankTask.executeCommand("add Plan a date with beloved girlfriend");
		result = testTankTask.executeCommand("1 done");
		assertEquals(result, "Task 1 is completed");
	}
	
	@Test
	public void testDoneEvent() {
		testTankTask.executeCommand("add Go on a date with beloved girlfriend event 24 DEC to 25 dec");
		result = testTankTask.executeCommand("done 1");
		assertEquals(result, "Task 1 is completed");
	}
	
	@Test
	public void testDoneEventAnotherWay() {
		testTankTask.executeCommand("add Go on a date with beloved girlfriend event 24 dec to 25 DEC");
		result = testTankTask.executeCommand("1 done");
		assertEquals(result, "Task 1 is completed");
	}
	
	@Test
	public void testDoneToDo() {
		testTankTask.executeCommand("add Get something for beloved girlfriend deadline 24 dec");
		result = testTankTask.executeCommand("1 done");
		assertEquals(result, "Task 1 is completed");
	}
	
	@Test
	public void testDoneToDoAnotherWay() {
		testTankTask.executeCommand("add Get something for beloved girlfriend deadline 24 dec");
		result = testTankTask.executeCommand("done 1");
		assertEquals(result, "Task 1 is completed");
	}
	
	@Test
	public void testUndoneFloat() {
		testTankTask.executeCommand("add Plan a date with beloved girlfriend");
		testTankTask.executeCommand("done 1");
		result = testTankTask.executeCommand("undone 1");
		assertEquals(result, "Task 1 is not completed");
	}
	
	@Test
	public void testUndoneEvent() {
		testTankTask.executeCommand("add Meeting with Supervisor B event 22 dec 10am to 22 dec 10am");
		testTankTask.executeCommand("done 1");
		result = testTankTask.executeCommand("undone 1");
		assertEquals(result, "Task 1 is not completed");
	}
	
	@Test
	public void testUndoneToDo() {
		testTankTask.executeCommand("add Get something for beloved girlfriend deadline 24 dec");
		testTankTask.executeCommand("done 1");
		result = testTankTask.executeCommand("undone 1");
		assertEquals(result, "Task 1 is not completed");
	}
	
	@Test
	public void testEmptyRedoStack() {
		result = testTankTask.executeCommand("redo");
		assertEquals(result,"Invalid Command. Please try again.");
	}
	
	// ================================================================
    // File Path Operations Test
    // ================================================================
	
	@Test 
	public void testFilePathNotFound() {
		String result = testTankTask.executeCommand("filepath C:\"Users\"Somewhere\"Not\"Found");
		assertEquals(result, "Invalid file path. Please try again");
	}
	
	// ================================================================
    // Search Operations Test
    // ================================================================
	
	@Test
	public void testSearchFoundByName(){
		testTankTask.executeCommand("add find beloved girlfriend");
		testTankTask.executeCommand("add Get something for beloved girlfriend deadline 24 dec");
		testTankTask.executeCommand("add Go on a date with beloved girlfriend event 24 dec to 25 dec");
		result = testTankTask.executeCommand("search beloved girlfriend");
		assertEquals(result,"search");
	}
	
	@Test
	public void testSearchFoundByDate(){
		testTankTask.executeCommand("add find beloved girlfriend");
		testTankTask.executeCommand("add Get something for beloved girlfriend deadline 24 dec");
		testTankTask.executeCommand("add Go on a date with beloved girlfriend event 24 dec to 25 dec");
		result = testTankTask.executeCommand("search 24 dec");
		assertEquals(result,"search");
	}
	
	@Test
	public void testSearchFoundByDescription(){
		testTankTask.executeCommand("add find beloved girlfriend des I love her lots");
		testTankTask.executeCommand("add Get something for beloved girlfriend deadline 24 dec  des I love her lots");
		testTankTask.executeCommand("add Go on a date with beloved girlfriend event 24 dec to 25 dec  des I love her lots");
		result = testTankTask.executeCommand("search I love her lots");
		assertEquals(result,"search");
	}
	
	@Test
	public void testSearchFoundByJumbledDescription(){
		testTankTask.executeCommand("add find beloved girlfriend des I love her lots");
		testTankTask.executeCommand("add Get something for beloved girlfriend deadline 24 dec  des I love her lots");
		testTankTask.executeCommand("add Go on a date with beloved girlfriend event 24 dec to 25 dec  des I love her lots");
		result = testTankTask.executeCommand("search Her love I");
		assertEquals(result,"search");
	}
	
	@Test
	public void testSearchFoundWithOtherCommandsIgnored(){
		testTankTask.executeCommand("add find beloved girlfriend");
		testTankTask.executeCommand("add Get something for beloved girlfriend deadline 24 dec");
		testTankTask.executeCommand("add Go on a date with beloved girlfriend event 24 dec to 25 dec");
		result = testTankTask.executeCommand("search beloved girlfriend add delete priority");
		assertEquals(result,"Input not found");
	}
	
	@Test
	public void testUpdatingOfSearchResults(){
		testTankTask.executeCommand("add find beloved girlfriend");
		testTankTask.executeCommand("add Get something for beloved girlfriend deadline 24 dec");
		testTankTask.executeCommand("add Go on a date with beloved girlfriend event 24 dec to 25 dec");
		result = testTankTask.executeCommand("search beloved girlfriend");
		testTankTask.executeCommand("1 pri 5");
		assertEquals(result,"search");
	}
	
	@Test
	public void testSearchNotFound() {
		result = testTankTask.executeCommand("search picnic with beloved girlfriend");
		assertEquals(result,"Input not found");
	}
	
	// ================================================================
    // Sort Operations Test
    // ================================================================
	
	@Test
	public void testSortPriorityLongForm() {
		testTankTask.executeCommand("add A pri 1");
		testTankTask.equals("add B pri 3");
		testTankTask.equals("add C pri 5");
		result = testTankTask.executeCommand("sort Priority");
		assertEquals(result, "All items sorted");
	}
	
	@Test
	public void testSortPriorityShortForm1() {
		testTankTask.executeCommand("add A pri 1");
		testTankTask.equals("add B pri 3");
		testTankTask.equals("add C pri 5");
		result = testTankTask.executeCommand("sort Pri");
		assertEquals(result, "All items sorted");
	}
	
	@Test
	public void testSortPriorityShortForm2() {
		testTankTask.executeCommand("add A pri 1");
		testTankTask.equals("add B pri 3");
		testTankTask.equals("add C pri 5");
		result = testTankTask.executeCommand("sortP");
		assertEquals(result, "All items sorted");
	}
	
	@Test
	public void testSortPriorityEvenLongerForm() {
		testTankTask.executeCommand("add A pri 1");
		testTankTask.equals("add B pri 3");
		testTankTask.equals("add C pri 5");
		result = testTankTask.executeCommand("sort by Priority");
		assertEquals(result, "All items sorted");
	}
	
	@Test 
	public void testSortNameLongForm() {
		testTankTask.executeCommand("add C pri 5");
		testTankTask.executeCommand("add B pri 3");
		testTankTask.executeCommand("add A pri 1");
		result = testTankTask.executeCommand("sort Name");
		assertEquals(result, "All items sorted");
	}
	
	@Test
	public void testSortNameEvenLongerForm() {
		testTankTask.executeCommand("add A pri 1");
		testTankTask.equals("add B pri 3");
		testTankTask.equals("add C pri 5");
		result = testTankTask.executeCommand("sort by Name");
		assertEquals(result, "All items sorted");
	}
	
	@Test 
	public void testSortNameShortForm() {
		testTankTask.executeCommand("add C pri 5");
		testTankTask.executeCommand("add B pri 3");
		testTankTask.executeCommand("add A pri 1");
		result = testTankTask.executeCommand("sortN");
		assertEquals(result, "All items sorted");
	}
	
	@Test
	public void testSortDeadlineLongForm() {
		testTankTask.executeCommand("add C pri 5 deadline today");
		testTankTask.executeCommand("add B pri 3 deadline tomorrow");
		testTankTask.executeCommand("add A pri 1 deadline next monday");
		result = testTankTask.executeCommand("sort Deadline");
		assertEquals(result,"All items sorted");
	}
	
	@Test
	public void testSortDeadlineShortForm() {
		testTankTask.executeCommand("add C pri 5 deadline today");
		testTankTask.executeCommand("add B pri 3 deadline tomorrow");
		testTankTask.executeCommand("add A pri 1 deadline next monday");
		result = testTankTask.executeCommand("sortD");
		assertEquals(result,"All items sorted");
	}
	
	@Test
	public void testSortDeadlineEvenLonger() {
		testTankTask.executeCommand("add C pri 5 deadline today");
		testTankTask.executeCommand("add B pri 3 deadline tomorrow");
		testTankTask.executeCommand("add A pri 1 deadline next monday");
		result = testTankTask.executeCommand("sort by Deadline");
		assertEquals(result,"All items sorted");
	}
	
	@Test
	public void testSortWrongField() {
		testTankTask.executeCommand("add C pri 5 deadline today");
		testTankTask.executeCommand("add B pri 3 deadline tomorrow");
		testTankTask.executeCommand("add A pri 1 deadline next monday");
		result = testTankTask.executeCommand("sort anyhow");
		assertEquals(result,"InvalidSortFieldError: 'anyhow' is not a valid sort field "
				+ "(please enter 'date', 'name' or 'priority')");
	}
	
	// ================================================================
    // Observer Operations Test
    // ================================================================
	
	@Test 
	public void testShowFloatLong() {
		result = testTankTask.executeCommand("show Floating");
		assertEquals(result, "showF");
	}
	
	@Test 
	public void testShowFloatShort() {
		result = testTankTask.executeCommand("showF");
		assertEquals(result, "showF");
	}
	
	@Test
	public void testShowOverdueLong() {
		result = testTankTask.executeCommand("show overdue");
		assertEquals(result, "showO");
	}
	
	@Test
	public void testShowOverdueShort() {
		result = testTankTask.executeCommand("showO");
		assertEquals(result, "showO");
	}
	
	@Test
	public void testShowEventsLong() {
		result = testTankTask.executeCommand("show events");
		assertEquals(result, "showE");
	}
	
	@Test
	public void testShowEventsShort() {
		result = testTankTask.executeCommand("showE");
		assertEquals(result, "showE");
	}
	
	@Test
	public void testShowTaskWrongType() {
		result = testTankTask.executeCommand("show test");
		assertEquals(result, "InvalidTaskTypeError: 'test' is not a valid task type "
				+ "(please enter 'todo', 'event', 'floating', 'today', 'overdue' or 'complete')");
	}
	
	@Test
	public void testUpdateFile() {
		String fileName = System.getProperty("user.home") + "/Desktop" + "/test.txt";
		result = testTankTask.executeCommand("filepath " + fileName);
		assertEquals(result, String.format("File path is updated successfully to %1$s", fileName));
	}
	
	@Test
	public void testUpdateFileDuplicate() {
		String fileName = System.getProperty("user.home") + "/Desktop" + "/filename.txt";
		result = testTankTask.executeCommand("filepath " + fileName);
		result = testTankTask.executeCommand("filepath " + fileName);
		assertEquals(result, String.format("File is already in %1$s. Please try again with a new file path.", fileName));
	}
	
	@Test
	public void testUpdateFileError() {
		result = testTankTask.executeCommand("filepath " + "/Desktop");
		assertEquals(result, "Invalid file path. Please try again");
	}

}
```
