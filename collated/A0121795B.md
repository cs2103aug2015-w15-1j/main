# A0121795B
###### src\main\java\backend\Parser\DateParser.java
``` java
 */
public class DateParser extends ParserSkeleton{
	
	//List of days in a week
	private final ArrayList<String> DAYS_OF_WEEK = new ArrayList<String>( Arrays.asList(
	"monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday" ) );
	
	//List of months and their abbreviations
	private final ArrayList<String> MONTHS = new ArrayList<String>( Arrays.asList(
	"january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december", 
	"jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "oct", "nov", "dec") );
	
	//Categorise the months by the number of days
	private final ArrayList<String> MONTHS_WITH_31_DAYS = new ArrayList<String>( Arrays.asList(
	"january", "march", "may", "july", "august", "october", "december") );
	private final ArrayList<String> MONTHS_WITH_30_DAYS = new ArrayList<String>( Arrays.asList(
	"april", "june", "september", "november") );
	private final String FEBRUARY = "february";
	
	//Abbreviations or numerical forms of the months
    private HashMap<String, ArrayList<String>> month_families = new HashMap<String, ArrayList<String>>(){
		static final long serialVersionUID = 1L; {
		put("january", new ArrayList<String>( Arrays.asList("jan", "1")));
		put("february", new ArrayList<String>( Arrays.asList("feb", "2")));
		put("march", new ArrayList<String>( Arrays.asList("mar", "3")));
        put("april", new ArrayList<String>( Arrays.asList("apr", "4")));
        put("may", new ArrayList<String>( Arrays.asList("may", "5"))); 
        put("june", new ArrayList<String>( Arrays.asList("jun", "6")));
        put("july", new ArrayList<String>( Arrays.asList("jul", "7")));
        put("august", new ArrayList<String>( Arrays.asList("aug", "8")));        
        put("september", new ArrayList<String>( Arrays.asList("sep", "9"))); 
        put("october", new ArrayList<String>( Arrays.asList("oct", "10")));
        put("november", new ArrayList<String>( Arrays.asList("nov", "11")));
        put("december", new ArrayList<String>( Arrays.asList("dec", "12")));
    }};
	
    //Date/time formats that are used by DateParser
	private final SimpleDateFormat DATEFORMAT_NATTY = new SimpleDateFormat("EEE MMM dd HH:mm:ss zzz yyyy");
	private final SimpleDateFormat DATEFORMAT_STANDARD = new SimpleDateFormat("EEE, dd MMM yy, hh:mma");
	private final SimpleDateFormat DATEFORMAT_NO_MINUTE = new SimpleDateFormat("EEE, dd MMM yy, hha");
	private final SimpleDateFormat DATEFORMAT_NO_TIME = new SimpleDateFormat("EEE, dd MMM yy");
	private final SimpleDateFormat DATEFORMAT_DAY_AND_MONTH_ONLY = new SimpleDateFormat("dd MMM");
	private final SimpleDateFormat DATEFORMAT_YEAR_ONLY = new SimpleDateFormat("yyyy");
	private final SimpleDateFormat TIMEFORMAT_STANDARD  = new SimpleDateFormat("hh:mma");
	private final SimpleDateFormat TIMEFORMAT_NO_MINUTE  = new SimpleDateFormat("hha");
	
	//The minimum abbreviation length accepted (eg. abbreviation of 'monday' can be 'mon' but not 'mo')
	private final int MIN_LENGTH_OF_ABBR = 3;
    
	//Special characters/words that are noted by DateParser and recognised by NATTY
	private final String DATE_SEPARATOR_COMMA = ", ";
	private final String DATE_SEPARATOR_SLASH = "/";
	private final String DATE_SEPARATOR_HYPHEN = "-";
	private final String TIME_SEPARATOR_COLON = ":";
	private final String TIME_SEPARATOR_DOT = ".";
	private final String PERIOD_AM = "am";
	private final String PERIOD_PM = "pm";
	private final String DATE_KEYWORD_LATER = "later";
	private final String DATE_KEYWORD_NEXT = "next";
	private final String DATE_KEYWORD_TODAY = "today";
	private final String DATE_KEYWORD_TOMORROW = "tomorrow";
	private final String DATE_KEYWORD_TOMORROW_ABBR = "tmr";
	private final String TIME_KEYWORD_HOUR = "hour";
	private final String TIME_KEYWORD_MINUTE = "minute";
	ArrayList<String> DAY_RELATIVE = new ArrayList<String>( 
			Arrays.asList(DATE_KEYWORD_TODAY, DATE_KEYWORD_TOMORROW, DATE_KEYWORD_TOMORROW_ABBR) );
	
    //A natural language date parser. Taken from http://natty.joestelmach.com/  
	private final com.joestelmach.natty.Parser NATTY = new com.joestelmach.natty.Parser();
	
	public DateParser() {
		//Force NATTY to set up upon DateParser creation by running NATTY once
    	String pi = "Mar 14 15 9.26pm";
    	parseDateWithNatty(pi);
	}
	
	/**
	 * This method parses a string (that resembles a date) into a standardized date format
	 */
	String parseDate(String date) {
		if (date.isEmpty()) {
			return date;
		}
	
		date = swapDayAndMonth(date);
		date = removeLater(date);
		date = addSpaceBetweenDayAndMonth(date);
		date = addFirstTwoDigitsToYear(date);
		
		String parsedDate = parseDateWithNatty(date);
		parsedDate = standardizeDateFormat(parsedDate);
		parsedDate = confirmDateIsInFuture(parsedDate);
		parsedDate = removeMinuteIfZero(parsedDate);
		return parsedDate;
	}

	ArrayList<String> parseEventStart(String eventStart) {
		ArrayList<String> eventStartValidity = isInvalidDate(eventStart);
		if (isErrorStatus(eventStartValidity)){
			return eventStartValidity;
		}
		
		String parsedStart = parseDate(eventStart);
		if (hasNoTime(eventStart)) {
			eventStart = getDayMonthAndYear(parsedStart) + DATE_SEPARATOR_COMMA + DEFAULT_STARTTIME;
		} else {
			eventStart = parsedStart;
		}
		return new ArrayList<String>( Arrays.asList(STATUS_OKAY, eventStart));
	}

	ArrayList<String> parseEventEnd(String eventStart, String eventEnd) {
		ArrayList<String> eventEndValidity = isInvalidDate(eventEnd);
		if (isErrorStatus(eventEndValidity)){
			return eventEndValidity;
		}
		String parsedEnd = parseDate(eventEnd);
		if (hasNoDate(eventEnd)) {
			eventEnd = getTime(parsedEnd);
		} else if (hasNoTime(eventEnd)) {
			eventEnd = getDayMonthAndYear(parsedEnd);
		} else {
			eventEnd = parsedEnd;
		}
		
		eventEnd = makeEventEndComplete(eventStart, eventEnd);
		
		return new ArrayList<String>( Arrays.asList(STATUS_OKAY, eventEnd));
	}

	ArrayList<String> isInvalidDate(String dateString){
		if (dateString.isEmpty()) {
			return new ArrayList<String>(Arrays.asList(STATUS_OKAY));
		}
		
		ArrayList<String> dateBoundCheck = checkDateBound(dateString);
		if (isErrorStatus(dateBoundCheck)) {
			return dateBoundCheck;
		}
		
		try {
			dateString = swapDayAndMonth(dateString);
			dateString = removeLater(dateString);
			dateString = addSpaceBetweenDayAndMonth(dateString);
			String parsedDate = parseDateWithNatty(dateString);
			parsedDate = removeMinuteIfZero(parsedDate);
			
			String parsedTime = getTime(parsedDate);
			String timeString = getTimeFromString(dateString);
			if (isNotMatchingTimes(parsedTime, timeString)) {
				return makeErrorResult(ERROR.INVALID_TIME, timeString);
			}
			if (!isValidHour(getHourFromTimeString(timeString))) {
				return makeErrorResult(ERROR.INVALID_TIME, timeString);
			}
			
			return new ArrayList<String>(Arrays.asList(STATUS_OKAY));
			
		} catch (Exception e){
			return makeErrorResult(ERROR.INVALID_DATE, dateString);
		}
	}

	boolean isDayOfWeek(String token) {
		token = removeEndSpacesOrBrackets(token.toLowerCase());
		if (DAYS_OF_WEEK.contains(token)){
			return true;
		}
		if (token.length() >= MIN_LENGTH_OF_ABBR) {
			for (String day: DAYS_OF_WEEK){
				if (day.startsWith(token)) {
					return true;
				}
			}
		}
		return false;
	}
	
	boolean isMonth(String token) {
		if (isNumber(token) && getDateSymbol(token).isEmpty() && hasOnlyOneWord(addSpaceBetweenDayAndMonth(token))) {
			return false;
		}
		token = convertMonthToDefault(token);
		if (MONTHS.contains(token)){
			return true;
		}
		for (String month: MONTHS) {
			if (hasMonth(token, month)) {
				return true;
			}
		}
		return false;
	}

	boolean hasNoDate(String dateString) {
		if (canBeSplit(dateString, DATE_SEPARATOR_SLASH) || canBeSplit(dateString, DATE_SEPARATOR_HYPHEN)) {
			return false;
		} else {
			ArrayList<String> tokens = new ArrayList<String>( Arrays.asList(dateString.split(" ") ));
			for (String token: tokens) {
				if (isMonth(token) || isDayOfWeek(token)) {
					return false;
				}
				if (isDateKeyword(token, tokens)) {
					return false;
				}
			}
		}
		return true;
	}
	
	boolean hasDate(String dateString) {
		return !hasNoDate(dateString);
	}

	/**
	 * This method checks if the user have included the time in the date string
	 */
	boolean hasNoTime(String dateString){
		ArrayList<String> eventTokens = new ArrayList<String>( Arrays.asList(dateString.split(" ")));
		for (String token: eventTokens){
			if (isValid12HourTime(token, eventTokens)){
				return false;
			}
			if (isValid24HourTime(token)){
				return false;
			}
		}
		return true;
	}

	boolean hasTime(String dateString) {
		return !hasNoTime(dateString);
	}

	String parseAndGetTime(String dateString) {
		dateString = parseDate(dateString);
		return getTime(dateString);
	}
	
	String parseAndGetDayOfWeek(String dateString) {
		dateString = parseDate(dateString);
		return getDayOfWeek(dateString);
	}
	
	String parseAndGetDayOfWeekAndTime(String dateString) {
		dateString = parseDate(dateString);
		return getDayOfWeek(dateString) + " " + getTime(dateString);
	}
	
	String parseAndGetMonth(String dateString) {
		dateString = parseDate(dateString);
		return getMonth(dateString);
	}
	
	String parseAndGetDayAndMonth(String dateString) {
		dateString = parseDate(dateString);
		return getDayAndMonth(dateString);
	}

	private String parseDateWithNatty(String date) {
		return NATTY.parse(date).get(0).getDates().toString();
	}

	private String standardizeDateFormat(String dateString) {
		dateString = removeEndSpacesOrBrackets(dateString);
		Date tempDate = convertStringToDate(dateString, DATEFORMAT_NATTY);
		return DATEFORMAT_STANDARD.format(tempDate);
	}

	private Date convertStringToDate(String dateString, SimpleDateFormat sdf){
		Date date = null;
		try {
			date = sdf.parse(dateString);
		} catch (ParseException e) {
			printParsingError(DATATYPE_STRING, dateString, DATATYPE_DATE);
			e.printStackTrace();
		}
		return date;
	}

	private Date convertStandardDateString(String dateString){
		Date date;
		if (hasMinute(dateString)) {
			date = convertStringToDate(dateString, DATEFORMAT_STANDARD);
		} else {
			date = convertStringToDate(dateString, DATEFORMAT_NO_MINUTE);
		}
		
		return date;
	}

	private Date convertStandardTimeString(String timeString){
		Date time;
		if (hasMinute(timeString)) {
			time = convertStringToDate(timeString, TIMEFORMAT_STANDARD);
		} else {
			time = convertStringToDate(timeString, TIMEFORMAT_NO_MINUTE);
		}
		
		return time;
	}

	private int convertTimeStringToInt(String timeString){
		try {
			return Integer.parseInt(timeString); 
		} catch (NumberFormatException e) {
			//printParsingError(DATATYPE_STRING, timeString, DATATYPE_INTEGER);
			//e.printStackTrace();
			return -1;
		}
	}

	/**
	 * This method swaps the position of day and month (so that it will work correctly for the natty parser)
	 */
	private String swapDayAndMonth(String date) {
		String[] dateTokens = date.split(" ");
		String dateSymbol = getDateSymbol(date);
		if (dateSymbol.isEmpty()) {
			return date;
		}
		String[] ddmmyyDate = {};
		String mmddyyDate = "";
		
		for (String token: dateTokens) {
			if (token.contains(dateSymbol)) {
				ddmmyyDate = token.split(dateSymbol);
				
				if (ddmmyyDate.length >= 2) {
					String day = ddmmyyDate[0];
					String month = ddmmyyDate[1];
					String year = "";
					mmddyyDate += month + DATE_SEPARATOR_SLASH + day;
					if (ddmmyyDate.length == 3) {
						year = ddmmyyDate[2];
						mmddyyDate += DATE_SEPARATOR_SLASH + year;
					} 
					mmddyyDate += " ";
				}
				
			} else {
				mmddyyDate += token + " ";
			}
		}
		
		mmddyyDate = removeEndSpacesOrBrackets(mmddyyDate);
		return mmddyyDate;
	}

	private String addFirstTwoDigitsToYear(String date) {
		String[] dateTokens = date.split(" ");
		String day = "";
		for (int i = 0; i < dateTokens.length; i++){
			String token = dateTokens[i];
			if (isNumber(token)) {
				if (day.isEmpty()) {
					day = token;
				} else if (token.length() != 4 && i != dateTokens.length-1 
						&& !getNext(dateTokens, i).toLowerCase().equals(PERIOD_AM) 
						&& !getNext(dateTokens, i).toLowerCase().equals(PERIOD_PM)){
					dateTokens[i] = getCurrentYearFirstTwoDigits() + token;
					break;
				}
			}
		}
		return mergeTokens(dateTokens, 0, dateTokens.length);
	}

	private String removeLater(String date) {
		String[] dateTokens = date.split(" ");
		date = "";
		for (String token: dateTokens) {
			if (!token.equalsIgnoreCase(DATE_KEYWORD_LATER)) {
				date += token + " ";
			}
		}
		return removeEndSpacesOrBrackets(date);
	}

	/**
	 * This method confirms that the date set by the parser is in the future
	 */
	private String confirmDateIsInFuture(String date) {
		if (isInThePast(date)) {
			int year = getYear(date);
			int currYear = getCurrentYearLastTwoDigits();
			if (year < currYear || year >= currYear + 5) {
				date = setToCurrentYear(date);
			}
			if (year <= currYear) {
				if (isInThePast(date)) {
					date = plusOneYear(date);
				}
			}
		}
		return date;
	}

	private String removeMinuteIfZero(String dateString) {
		if (dateString.contains(TIME_SEPARATOR_COLON)) {
			String time = getTime(dateString);
			int hour = getHour(time);
			int minute = getMinute(time);
			String period = getPeriod(time);
			
			if (minute == 0) {
				time = hour + period;
			} else {
				if (minute < 10) {
					time = hour + TIME_SEPARATOR_COLON + ZERO + minute + period;
				} else {
					time = hour + TIME_SEPARATOR_COLON + minute + period;
				}
			}
			
			String[] dateTokens = dateString.split(DATE_SEPARATOR_COMMA);
			return getFirst(dateTokens) + DATE_SEPARATOR_COMMA + getSecond(dateTokens) + DATE_SEPARATOR_COMMA + time;
		} 
		return dateString;
	}

	private String makeEventEndComplete(String eventStart, String eventEnd) {
		String startDate = getDayMonthAndYear(eventStart);
		String startTime = getTime(eventStart);
		
		if (eventEnd.isEmpty()) {
			eventEnd = startDate + DATE_SEPARATOR_COMMA + DEFAULT_ENDTIME;
		} else if (hasNoDate(eventEnd)) {
			String endTime = eventEnd;
			if (isStartTimeNotBeforeEndTime(startTime, endTime)) {
				startDate = plusOneDay(startDate, DATEFORMAT_NO_TIME);
			} 
			eventEnd = startDate + DATE_SEPARATOR_COMMA + endTime;	
		} else if (hasNoTime(eventEnd)) {
			String endDate = eventEnd;
			eventEnd = endDate + DATE_SEPARATOR_COMMA + DEFAULT_ENDTIME;
		}
		
		if (isStartDateAfterEndDate(eventStart, eventEnd)) {
			eventEnd = plusOneYear(eventEnd);
		}
		return eventEnd;
	}

	private Date adjustCalendar(int field, Date date, int length) {
		Calendar c = Calendar.getInstance(); 
		c.setTime(date); 
		c.add(field, length);
		Date newDate = c.getTime();
		return newDate;
	}
	
	private String plusOneDay(String dateString, SimpleDateFormat sdf) {
		Date date = new Date();
		date = convertStringToDate(dateString, sdf);
		date = adjustCalendar(Calendar.DATE, date, 1);
		return sdf.format(date);
	}
	
	private String plusOneYear(String dateString) {
		Date date = convertStandardDateString(dateString);
		date = adjustCalendar(Calendar.YEAR, date, 1);
		return removeMinuteIfZero(standardizeDateFormat(date.toString()));
	}

	private String setToCurrentYear(String dateString) {
		String currYear = Integer.toString(getCurrentYearLastTwoDigits());
		String[] dateTokens = dateString.split(DATE_SEPARATOR_COMMA);
		
		String ddMMMyy = getSecond(dateTokens);
		String[] ddMMMyyTokens = ddMMMyy.split(" ");
		ddMMMyy = getFirst(ddMMMyyTokens) + " " + getSecond(ddMMMyyTokens) + " " + currYear;
		
		String ddMMM = getFirst(ddMMMyyTokens) + " " + getSecond(ddMMMyyTokens);
		String EEE = getDayOfWeek(parseDate(ddMMM + " " + getLast(dateTokens)));
		
		return EEE + DATE_SEPARATOR_COMMA + ddMMMyy + DATE_SEPARATOR_COMMA + getLast(dateTokens);
	}

	private String getDateSymbol(String date) {
		if (date.contains(DATE_SEPARATOR_SLASH)){
			return DATE_SEPARATOR_SLASH;
		} else if (date.contains(DATE_SEPARATOR_HYPHEN)) {
			return DATE_SEPARATOR_HYPHEN;
		} else {
			return "";
		}
	}

	private String getDayOfWeek(String dateString) {
		String[] dateTokens = dateString.split(DATE_SEPARATOR_COMMA);
		return getFirst(dateTokens);
	}
	
	private String getDayAndMonth(String dateString) {
		String[] dateTokens = dateString.split(DATE_SEPARATOR_COMMA);
		String ddMMMyy = getSecond(dateTokens);
		String[] ddMMMyyTokens = ddMMMyy.split(" ");
		return getFirst(ddMMMyyTokens) + " " + getSecond(ddMMMyyTokens);
	}
	
	private String getMonth(String dateString) {
		String[] dateTokens = dateString.split(DATE_SEPARATOR_COMMA);
		String ddMMMyy = getSecond(dateTokens);
		String[] ddMMMyyTokens = ddMMMyy.split(" ");
		return getSecond(ddMMMyyTokens);
	}

	private int getYear(String dateString) {
		String[] dateTokens = dateString.split(DATE_SEPARATOR_COMMA);
		String ddMMMyy = getSecond(dateTokens);
		String[] ddMMMyyTokens = ddMMMyy.split(" ");
		return Integer.parseInt(getLast(ddMMMyyTokens));
	}

	private String getDayMonthAndYear(String dateString) {
		String[] dateTokens = dateString.split(DATE_SEPARATOR_COMMA);
		return getFirst(dateTokens) + DATE_SEPARATOR_COMMA + getSecond(dateTokens);
	}

	private String getTime(String dateString) {
		String[] dateTokens = dateString.split(DATE_SEPARATOR_COMMA);
		return getLast(dateTokens);
	}

	private String getTimeSymbol(String timeString) {
		if (timeString.contains(TIME_SEPARATOR_COLON)){
			return TIME_SEPARATOR_COLON;
		} else if (timeString.contains(TIME_SEPARATOR_DOT)) {
			return "\\" + TIME_SEPARATOR_DOT;
		} else {
			return "";
		}
	}

	private int getHour(String timeString) {
		String[] timeTokens;
		timeTokens = timeString.split(TIME_SEPARATOR_COLON);
		
		int hour = convertTimeStringToInt(getFirst(timeTokens));
		return hour;
	}

	private int getMinute(String timeString) {
		String[] timeTokens;
		timeTokens = timeString.split(TIME_SEPARATOR_COLON);
		if (timeTokens.length > 1) {
			String minuteWithPeriod = getSecond(timeTokens);
			String[] minuteToken;
			if (isAM(timeString)) {
				minuteToken = minuteWithPeriod.toLowerCase().split(PERIOD_AM);
			} else {
				minuteToken = getSecond(timeTokens).toLowerCase().split(PERIOD_PM);
			}
			return convertTimeStringToInt(getFirst(minuteToken));
		} else {
			return 0;
		}
	}

	private String getPeriod(String timeString){
		if (isAM((timeString))) {
			return PERIOD_AM;
		}
		if (isPM((timeString))) {
			return PERIOD_PM;
		}
		return STATUS_ERROR;
	}

	private Date getCurrentDate() {
		Date now = new Date();
		return now;
	}
	
	private String getCurrentYearFirstTwoDigits() {
	    Date now = new Date();
	    String strDate = DATEFORMAT_YEAR_ONLY.format(now);
	    return strDate.substring(0, 2);
	}
	
	private int getCurrentYearLastTwoDigits() {
	    Date now = new Date();
	    String strDate = DATEFORMAT_YEAR_ONLY.format(now);
	    strDate = strDate.substring(2, strDate.length());
		return Integer.parseInt(strDate);
	}
	
	private int getDayfromDateString(String token) {
		String day = getFirst(token.split(getDateSymbol(token)));
		try {
			return Integer.parseInt(day);
		} catch (NumberFormatException e) {
			printParsingError(FREQUENCY_DAY, day, DATATYPE_INTEGER);
			e.printStackTrace();
			return -1;
		}
	}

	private String getMonthfromDateString(String token) {
		String sym = getDateSymbol(token);
		if (!sym.isEmpty()) {
			return getSecond(token.split(getDateSymbol(token)));
		} else {
			String[] tokens = token.split(" ");
			if (isNumber(getFirst(tokens))) {
				return getSecond(tokens);
			} else {
				return getFirst(tokens);
			}
		}
	}

	private String getTimeFromString(String dateString) {
		ArrayList<String> dateTokens = new ArrayList<String>( Arrays.asList(dateString.split(" ")));
		for (String token: dateTokens) {
			if (isTimeFormat(token)) {
				if (token.equalsIgnoreCase(PERIOD_AM) || token.equalsIgnoreCase(PERIOD_PM)) {
					return getPrevious(dateTokens, token) + " " + token;
				}
				return token;
			}
		}
		return "";
	}

	private String getHourFromTimeString(String timeString){
		String sym = getTimeSymbol(timeString);
		if (!sym.isEmpty()){
			return getFirst(timeString.split(sym));
		}
		if (isAM(timeString)) {
			String hour = getFirst(timeString.toLowerCase().split(PERIOD_AM));
			return removeEndSpacesOrBrackets(hour);
		}
		if (isPM(timeString)) {
			String hour = getFirst(timeString.toLowerCase().split(PERIOD_PM));
			return removeEndSpacesOrBrackets(hour);
		}
		return timeString;
	}

	private boolean isStartDateAfterEndDate(String startDateString, String endDateString){
		Date startDate = convertStandardDateString(startDateString);
		Date endDate = convertStandardDateString(endDateString);
		return startDate.after(endDate);
	}

	private boolean isStartTimeNotBeforeEndTime(String startTime, String endTime){
		Date startTimeDate = convertStandardTimeString(startTime);
		Date endTimeDate = convertStandardTimeString(endTime);
		return !startTimeDate.before(endTimeDate);
	}

	private boolean isInThePast(String dateString){
		Date date = new Date();
		if (dateString.split(" ").length == 2) {
			date = convertStringToDate(dateString, DATEFORMAT_DAY_AND_MONTH_ONLY);
		} else
			date = convertStandardDateString(dateString);
		
		Date now = getCurrentDate();
		return now.after(date);
	}

	private boolean isDayMonthFormat(String token) {
		return !getDateSymbol(token).isEmpty() && !getNumber(token).isEmpty();
	}

	private boolean isTimeFormat(String time){
		return isAM(time) || isPM(time) || !getTimeSymbol(time).isEmpty();
	}

	private boolean isDateKeyword(String token, ArrayList<String> tokenArray) {
		if (DAY_RELATIVE.contains(token.toLowerCase())) {
			return true;
		} 
		
		if (DATE_FREQUENCY.contains(removePluralOrPastTense(token.toLowerCase()))) {
			String previousToken = getPrevious(tokenArray, token);
			if (previousToken != null) {
				if (isNumber(previousToken) || previousToken.equalsIgnoreCase(DATE_KEYWORD_NEXT)) {
					return true;
				}
			}
		} 
		
		return false;
	}

	private boolean isValid12HourTime(String token, ArrayList<String> tokens) {
		String period;
		if (isAM(token)) {
			period = PERIOD_AM;
		} else if (isPM(token)) {
			period = PERIOD_PM;
		} else {
			return false;
		}
		String[] timeTokens = token.toLowerCase().split(period);
		if (timeTokens.length <= 1) {
			String time = "";
			if (timeTokens.length == 1){
				time = getFirst(timeTokens);
			} else if (timeTokens.length == 0){
				time = getPrevious(tokens, token);
			}
			if (isTimeFormat(time)) {
				return isValid24HourTime(time);
			} else {
				return isValidHour(time);
			}
		}
		return false;
	}

	private boolean isValid24HourTime(String token) {
		String timeSymbol;
		if (token.contains(TIME_SEPARATOR_COLON)) {
			timeSymbol = TIME_SEPARATOR_COLON;
		} else if (token.contains(TIME_SEPARATOR_DOT)) {
			timeSymbol = TIME_SEPARATOR_DOT;
		} else {
			return false;
		}
		
		String[] timeTokens = token.split(timeSymbol);
		if (timeTokens.length == 2){
			String hour = getFirst(timeTokens);
			String minute = getLast(timeTokens);
			if (isAM(token)) {
				minute = getFirst(minute.split(PERIOD_AM));
			}
			if (isPM(token)) {
				minute = getFirst(minute.split(PERIOD_PM));
			}
			if (isValidHour(hour) && isValidMinute(minute)) {
				return true;
			}
		}
		return false;
	}

	private boolean isAM(String time){
		return time.toLowerCase().endsWith(PERIOD_AM);
	}

	private boolean isPM(String time){
		return time.toLowerCase().endsWith(PERIOD_PM);
	}

	private boolean isValidHour(String hour){
		int minHour = 0;
		int maxHour = 23;
		if (hour.isEmpty()) {
			return true;
		}
		try {
			int min = Integer.parseInt(hour);
			return min >= minHour && min <= maxHour;
		} catch (NumberFormatException e) {
			printParsingError(TIME_KEYWORD_HOUR, hour, DATATYPE_INTEGER);
			e.printStackTrace();
			return false;
		}
	}
	
	private boolean isValidMinute(String minute){
		try {
			int min = Integer.parseInt(minute);
			return min >= 0 && min <= 60;
		} catch (NumberFormatException e) {
			printParsingError(TIME_KEYWORD_MINUTE, minute, DATATYPE_INTEGER);
			e.printStackTrace();
			return false;
		}
	}
	
	private boolean isNotMatchingTimes(String parsedTime, String timeString) {
		return !hasMinute(parsedTime) && (hasMinute(timeString) && !timeString.endsWith(ZERO));
	}

	private boolean hasMinute(String time){
		return canBeSplit(time, TIME_SEPARATOR_COLON);
	}

	private boolean hasMonth (String token, String month){
		return (token.startsWith(month) || token.endsWith(month));
	}

	private boolean hasNoSuchDayInMonth(int day, String month) {
		month = removeFrontZero(month.toLowerCase());
		if (has31Days(month)) {
			return day > 31;
		}
		if (has30Days(month)) {
			return day > 30;
		}
		if (isFebruary(month)) {
			return day > 29;
		}
		return true;
	}

	private boolean has31Days(String month){
		return MONTHS_WITH_31_DAYS.contains(convertMonthToDefault(month));
	}

	private boolean has30Days(String month){
		return MONTHS_WITH_30_DAYS.contains(convertMonthToDefault(month));
	}

	private boolean isFebruary(String month){
		return FEBRUARY.equals(convertMonthToDefault(month));
	}

	private int getMaxDay(String month){
		month = month.toLowerCase();
		if (has31Days(month)) {
			return 31;
		}
		if (has30Days(month)) {
			return 30;
		}
		if (isFebruary(month)) {
			return 29;
		}
		return -1;
	}

	private String addSpaceBetweenDayAndMonth(String dateString) {
		String[] dateTokens = dateString.split(" ");
		findMonth:
		for (int i = 0; i < dateTokens.length; i++) {
			String token = dateTokens[i];
			token = token.toLowerCase();
			for (String month: MONTHS) {
				if (hasMonth(token, month) && !getNumber(token).isEmpty()){
					dateTokens[i] = getNumber(token) + " " + month;
					break findMonth;
				}
			}
		}
		return mergeTokens(dateTokens, 0, dateTokens.length);
	}

	private ArrayList<String> checkDateBound(String dateString) {
		String[] dateTokens = dateString.split(" ");
		for (int i = 0; i < dateTokens.length; i++) {
			String token = dateTokens[i];
			int day = -1;
			String month = "";
			if (isDayMonthFormat(token)) {
				day = getDayfromDateString(token);
				month = getMonthfromDateString(token);
				if (hasNoSuchDayInMonth(day, month)) {
					return makeErrorResult(ERROR.INVALID_DAYOFMONTH, Integer.toString(day) + DATE_SEPARATOR_SLASH + month);
				}
			}
			if (isMonth(token)) {
				token = addSpaceBetweenDayAndMonth(token);
				if (canBeSplit(token, " ")) {
	
					day = convertStringToInt(getFirst(token));
					month = getLast(token);
				} else {
					String prev = getPrevious(dateTokens, i);
					month = token;
					if (isNumber(prev)) {
						day = convertStringToInt(prev);
						if (hasNoSuchDayInMonth(day, month)) {
							return makeErrorResult(ERROR.INVALID_DAYOFMONTH, Integer.toString(day) + " " + month);
						}
					} else {
						day = convertStringToInt(getNext(dateTokens, i));
						if (hasNoSuchDayInMonth(day, month)) {
							return makeErrorResult(ERROR.INVALID_DAYOFMONTH, month + " " + Integer.toString(day));
						}
					}
					
				}
			}
		}
		return new ArrayList<String>( Arrays.asList(STATUS_OKAY));
	}

	private String convertMonthToDefault(String token) {
		token = token.toLowerCase();
		for (String month: month_families.keySet()) {
			ArrayList<String> family = month_families.get(month);
			if (family.contains(token)) {
				return month;
			}
		}
		return token;
	}
	
	@Override
	ArrayList<String> makeErrorResult(ERROR error, String token) {
		ArrayList<String> result = new ArrayList<String>(); 
		result.add(STATUS_ERROR);
		
		switch (error) {
			case INVALID_DATE:
				result.add("InvalidDateError: '" + token + "' is not an acceptable date format");
				break;
			case INVALID_TIME:
				result.add("InvalidTimeError: '" + token + "' is not an acceptable time format");
				break;
			case INVALID_DAYOFMONTH:
				String month = getMonthfromDateString(token);
				String defaultMonth = convertMonthToDefault(month);
				result.add("InvalidDayOfMonthError: The date '" + token + "' does not exist "
						+ "(" + capitalize(defaultMonth) + " only has " + getMaxDay(defaultMonth) + " days!)");
				break;
			default:
				break; 
		}
		return result;
	}
}
```
###### src\main\java\backend\Parser\Parser.java
``` java
 */
public class Parser extends ParserSkeleton{
	
	ParserVault parserVault = new ParserVault();
	
	//Tokens are used to 'grow' (merged into) a growingToken until it is stored into field content
	private String growingToken = "";
	
	//Result types that include more than one field
	private final ArrayList<String> MULTIFIELD_RESULT_TYPE = new ArrayList<String>( 
	Arrays.asList(RESULTTYPE_ADD, RESULTTYPE_SET) );
	
	/**
	 * This method parses the user input and returns an ArrayList of string tokens
	 */
	public ArrayList<String> parseInput(String input){
		parserVault.resetContents();
		String[] inputTokens = input.split(SPACE_OF_ANY_LENGTH);
		ArrayList<String> firstTwoWordsParsed = parseFirstTwoWords(inputTokens);
		
		if (isParsingCompleted(firstTwoWordsParsed)) {
			return firstTwoWordsParsed;
		} else {
			return parseRemaining(inputTokens);	
		}
	}
	
	private ArrayList<String> parseFirstTwoWords(String[] inputTokens) {
		String firstWordOriginal = getFirst(inputTokens);
		String firstWord = parserVault.convertVariantToDefault(firstWordOriginal);
		String secondWordOriginal = getSecond(inputTokens);
		String secondWord = parserVault.convertVariantToDefault(secondWordOriginal);
		int inputWordCount = inputTokens.length;
		if (isCommandThatNoNeedContent(firstWord)) {
			return parserVault.makeCommandOnlyResult(firstWord);
		}
		if (isCommandButHasNoContent(firstWord, inputWordCount)) {
			return makeErrorResult(ERROR.EMPTY_FIELD, firstWord);
		}
		if (isNotCommandOrIndex(firstWord)) {
			return makeErrorResult(ERROR.INVALID_WORD, firstWordOriginal);
		} 
		if (isDominatingCommand(firstWord)) {
			String content = mergeTokens(inputTokens, 1, inputTokens.length);
			ArrayList<String> dominantResult = parserVault.makeDominantResult(firstWord, secondWord, content); 
			if (isParsingCompleted(dominantResult)) {
				return dominantResult;
			}
		}
		if (isCommandButCannotBeInOneShot(secondWord)) {
			String content = mergeTokens(inputTokens, 1, inputTokens.length);
			ArrayList<String> dominantResult = parserVault.makeDominantResult(secondWord, firstWord, content); 
			if (isParsingCompleted(dominantResult)) {
				return dominantResult;
			}
		}
		if (isNumber(firstWord)) {
			if (secondWord.isEmpty()) {
				return makeErrorResult(ERROR.NO_COMMAND, firstWord);
			} else if (isNotCommand(secondWord)) {
				return makeErrorResult(ERROR.INVALID_COMMAND, secondWordOriginal);
			}
		}
		return new ArrayList<String>( Arrays.asList(STATUS_INCOMPLETE));
	}

	private ArrayList<String> parseRemaining(String[] inputTokens) {
		int inputWordCount = inputTokens.length;
		boolean hasQuotes = hasQuotes(inputTokens);
		boolean quoteStart = false;
		
		for (int i = 0; i < inputWordCount; i++) {
			String token = inputTokens[i];
			String originalToken = token;
			token = parserVault.convertVariantToDefault(token);
			
			quoteStart = checkForQuotes(hasQuotes, quoteStart, originalToken, i, inputTokens); 
			if (quoteStart) {
				growToken(originalToken);
				
			} else {
				ArrayList<String> parseResult = parseToken(token, originalToken, i, inputWordCount);
				if (isErrorStatus(parseResult)) {
					return parseResult;
				}
			}
		}
		
		growingToken = parserVault.storeToken(growingToken);
		String resultType = parserVault.getResultType();
		if (canHaveMultipleFields(resultType)) {
			return parserVault.makeMultiFieldResult();
		} else {
			return parserVault.makeSingleFieldResult();
		}
	}

	private ArrayList<String> parseToken(String token, String originalToken, int count, int total) {
		if (isNotCommand(token) || isCommandButRepressed(token)){
			growToken(originalToken);	
		} else {
			growingToken = parserVault.storeToken(growingToken);
			String lastCommandSeen = parserVault.getLastSeenCommand();
			
			if (isLastWord(count, total) && isCommandThatNeedWords(lastCommandSeen)) {
				growToken(originalToken);
			} else if (isLastWord(count, total) && !isCommandButRepressed(token)){
				return makeErrorResult(ERROR.EMPTY_FIELD, originalToken);
			} else if (parserVault.isSeenCommand(token)) {
				if (isCommandThatNeedWords(lastCommandSeen)) {
					growingToken = parserVault.storeToken(originalToken);
				} else if (!token.equals(COMMAND_RECUR)){
					return makeErrorResult(ERROR.DUPLICATE_COMMAND, originalToken);
				}
			} else {
				if (!lastCommandSeen.isEmpty()) {
					String contentOfLastCommand = parserVault.getContentOfCommand(lastCommandSeen);
					if (contentOfLastCommand.isEmpty()) {
						return makeErrorResult(ERROR.EMPTY_FIELD, lastCommandSeen);
					}
				}
				parserVault.storeCommand(token);
			}
		}
		return new ArrayList<String>( Arrays.asList(STATUS_OKAY));
	}

	private void growToken(String token) {
		growingToken += token + " ";
	}

	private boolean checkForQuotes(boolean hasQuote, boolean quoteStart, String token, 
			int count, String[] inputTokens) {
		if (hasQuote && token.startsWith(QUOTATION_MARK)) {
			quoteStart = true;
		}
		
		if (quoteStart == true) {
			String previousToken = getPrevious(inputTokens, count);
			if (previousToken.endsWith(QUOTATION_MARK)) {
				quoteStart = false;
			}
		}
		
		return quoteStart;
	}

	private boolean hasQuotes(String[] inputTokens){
		int quoteCommaCount = 0;
		for (String token: inputTokens) {
			if (token.startsWith(QUOTATION_MARK)) {
				quoteCommaCount++;
			}
			if (token.endsWith(QUOTATION_MARK)) {
				quoteCommaCount++;
			}
		}
		return quoteCommaCount > 1 && quoteCommaCount % 2 == 0;
	}

	private boolean isCommand(String token){
		return COMMANDS.contains(token);
	}

	private boolean isCommandButHasNoContent(String token, int inputWordCount) {
		return isCommand(token) && inputWordCount == 1;
	}

	private boolean isNotCommand(String token){
		return !isCommand(token);
	}

	private boolean isNotCommandOrIndex(String token) {
		return isNotCommand(token) && !isNumber(token);
	}

	private boolean isLastWord(int i, int inputWordCount) {
		return i == inputWordCount-1;
	}

	private boolean isCommandButRepressed(String token) {
		String mainCommand = parserVault.getResultType();
		return !mainCommand.isEmpty() && (isDominatingCommand(token) || isCommandThatNoNeedContent(token));
	}
	
	private boolean canHaveMultipleFields(String token) {
		return MULTIFIELD_RESULT_TYPE.contains(token);
	}

	@Override
	ArrayList<String> makeErrorResult(ERROR error, String token) {
		
		ArrayList<String> result = new ArrayList<String>(); 
		result.add(STATUS_ERROR);
		switch (error) {
			case INVALID_WORD:
				result.add("InvalidWordError: '" + token + "' is not recognised as a command or index");
				break;
			case INVALID_COMMAND:
				result.add("InvalidCommandError: '" + token + "' is not recognised as a command");
				break;
			case NO_COMMAND:
				result.add("NoCommandError: Please enter a command after the task index '" + token + "'");
				break;
			case DUPLICATE_COMMAND:
				result.add("DuplicateCommandError: Duplicate command '" + token + "'");
				break;
			case EMPTY_FIELD:
				result.add("EmptyFieldError: Please enter content for the command '" + token + "'");
				break;
			default:
				break; 
		}
		return result;
	}
}
```
###### src\main\java\backend\Parser\ParserSkeleton.java
``` java
 */
abstract class ParserSkeleton {
	
	//Command words that are accepted by the program
	final String COMMAND_ADD = "add";
	final String COMMAND_DEADLINE = "deadline";
	final String COMMAND_DESCRIPTION = "description";
	final String COMMAND_DELETE = "delete";
	final String COMMAND_DELETEALL = "deleteAll";
	final String COMMAND_DONE = "done";
	final String COMMAND_EVENTSTART = "event";
	final String COMMAND_EVENTEND = "to";
	final String COMMAND_RECUR = "every";
	final String COMMAND_EXIT = "exit";
	final String COMMAND_FILEPATH = "filepath";
	final String COMMAND_PRIORITY = "priority";
	final String COMMAND_REDO = "redo";
	final String COMMAND_REMINDER = "reminder";
	final String COMMAND_RENAME = "rename";
	final String COMMAND_RESET = "reset";
	final String COMMAND_SEARCH = "search";
	final String COMMAND_SHOW = "show";
	final String COMMAND_SHOWCOMPLETE = "showC";
	final String COMMAND_SHOWTODAY = "showD";
	final String COMMAND_SHOWEVENT = "showE";
	final String COMMAND_SHOWFLOATING = "showF";
	final String COMMAND_SHOWOVERDUE = "showO";
	final String cOMMAND_SHOWTODO = "showT";
	final String COMMAND_SORT = "sort";
	final String COMMAND_SORTD = "sortD";
	final String COMMAND_SORTN = "sortN";
	final String COMMAND_SORTP = "sortP";
	final String COMMAND_UNDO = "undo";
	final String COMMAND_UNDONE = "undone";
	
	//List of all command words accepted by the program
	final ArrayList<String> COMMANDS = new ArrayList<String>( Arrays.asList(
	COMMAND_ADD, COMMAND_DEADLINE, COMMAND_DELETE, COMMAND_DELETEALL, COMMAND_DESCRIPTION,
	COMMAND_DONE, COMMAND_EVENTSTART, COMMAND_RECUR, COMMAND_EXIT, COMMAND_FILEPATH, COMMAND_PRIORITY, 
	COMMAND_REDO, COMMAND_REMINDER, COMMAND_RENAME, COMMAND_RESET, COMMAND_SEARCH, COMMAND_SHOW, 
	COMMAND_SHOWCOMPLETE, COMMAND_SHOWEVENT, COMMAND_SHOWFLOATING, COMMAND_SHOWOVERDUE, cOMMAND_SHOWTODO, 
	COMMAND_SHOWTODAY, COMMAND_SORT, COMMAND_SORTD, COMMAND_SORTN, COMMAND_SORTP, COMMAND_UNDO, COMMAND_UNDONE ) );
	
	//Command words that work by just typing the command word (without additional content)
	final ArrayList<String> COMMANDS_NO_CONTENT = new ArrayList<String>( Arrays.asList(
	COMMAND_DELETEALL, COMMAND_EXIT, COMMAND_REDO, COMMAND_SHOWCOMPLETE, COMMAND_SHOWEVENT, COMMAND_SHOWFLOATING, 
	COMMAND_SHOWOVERDUE, cOMMAND_SHOWTODO, COMMAND_SHOWTODAY, COMMAND_SORTD, COMMAND_SORTN, COMMAND_SORTP, COMMAND_UNDO ) );
	
	//Command words that if appear first, will prevent other command words from having effect
	final ArrayList<String> COMMANDS_DOMINATING = new ArrayList<String>( Arrays.asList(
	COMMAND_DELETE, COMMAND_DONE, COMMAND_FILEPATH, COMMAND_RESET, COMMAND_SEARCH, COMMAND_SHOW, 
	COMMAND_SORT, COMMAND_UNDONE ) );
	
	//Command words that can accept any amount of words
	final ArrayList<String> COMMANDS_NEED_WORDS = new ArrayList<String>( 
	Arrays.asList(COMMAND_ADD, COMMAND_DESCRIPTION, COMMAND_FILEPATH, COMMAND_SEARCH) );
	
	//Command words that cannot be part of a one-shot command
	final ArrayList<String> COMMANDS_NOT_ONE_SHOT = new ArrayList<String>( 
	Arrays.asList(COMMAND_DELETE, COMMAND_DONE, COMMAND_RESET, COMMAND_UNDONE) );	
	
	//The default times set by Parser if user never indicates the time
	final String DEFAULT_DEADLINE = "11:59pm";
	final String DEFAULT_STARTTIME = "9am";
	final String DEFAULT_ENDTIME = "9pm";
	
	//The date frequencies that can be used to specify a date or a task's recurrence
	final String FREQUENCY_DAY = "day";
	final String FREQUENCY_WEEK = "week";
	final String FREQUENCY_MONTH = "month";
	final String FREQUENCY_YEAR = "year";
	final ArrayList<String> DATE_FREQUENCY = new ArrayList<String>( Arrays.asList(
	FREQUENCY_DAY, FREQUENCY_WEEK, FREQUENCY_MONTH, FREQUENCY_YEAR) );
	
	//The two result types that require a multi-field result
	final String RESULTTYPE_ADD = "add";
	final String RESULTTYPE_SET = "set";
	
	//Types of statuses that can be returned by a method
	final String STATUS_ERROR = "error";
	final String STATUS_INCOMPLETE = "incomplete";
	final String STATUS_OKAY = "okay";
	
	//Java data types that are converted by Parser
	final String DATATYPE_DATE = "date";
	final String DATATYPE_INTEGER = "integer";
	final String DATATYPE_STRING = "string";
	
	//Special characters that are noted by Parser
	final String SPACE_OF_ANY_LENGTH = " +";
	final String QUOTATION_MARK = "\"";
	final String ZERO = "0";
	
	//All the errors that can be detected by Parser
	enum ERROR {
		INVALID_WORD, INVALID_COMMAND, NO_COMMAND, DUPLICATE_COMMAND, EMPTY_FIELD,
		INVALID_INDEX, NO_END_DATE, INVALID_PRIORITY, INVALID_DATE, CONFLICTING_DATES,
		INVALID_FREQUENCY, INVALID_TASKTYPE, INVALID_SORTFIELD, INVALID_RESET, 
		NO_DATE_FOR_RECURRENCE, INVALID_TIME, INVALID_DAYOFMONTH;
	}
	
	String getFirst(String[] array){
		return array[0];
	}

	String getFirst(String str){
		return str.split(" ")[0];
	}

	String getFirst(ArrayList<String> arrayList){
		return arrayList.get(0);
	}

	String getSecond(String[] array){
		if (array.length < 2) {
			return "";
		}
		return array[1];
	}
	
	String getSecond(String str){
		return str.split(" ")[1];
	}

	String getPrevious(ArrayList<String> list, String token) {
		if (list.size() > 1 && list.indexOf(token) != 0) {
			return list.get( list.indexOf(token)-1 );
		}
		return null;
	}

	String getPrevious(String[] list, int count) {
		if (count != 0) {
			return list[count - 1];
		}
		return null;
	}
	
	String getNext(String[] list, int count) {
		if (count != list.length-1) {
			return list[count + 1];
		}
		return null;
	}

	String getLast(String[] array){
		if (array.length == 0) {
			return "";
		}
		return array[array.length-1];
	}

	String getLast(String str){
		return str.split(" ")[str.split(" ").length-1];
	}
	
	String getLast(ArrayList<String> arrayList){
		if (arrayList.isEmpty()) {
			return "";
		}
		return arrayList.get(arrayList.size()-1);
	}

	String getNumber(String token){
		if (isNumber(token)){
			return token;
		} else {
			String c;
			String number = "";
			for (int i = 0; i < token.length(); i++) {
				c = token.substring(i, i+1);
				if (isNumber(c)) {
					number += c;
				}
			}
			return number;
		}
	}
	
	String getStatus(ArrayList<String> parseResult) {
		return getFirst(parseResult);
	}

	int convertStringToInt(String str){
		try {
			return Integer.parseInt(str);
		} catch (Exception e) {
			//printParsingError(DATATYPE_STRING, str, DATATYPE_INTEGER);
			return -1;
		}
	}

	String capitalize(String word) {
		return Character.toUpperCase(word.charAt(0)) + word.substring(1);
	}

	String mergeTokens(String[] tokens, int startIndex, int endIndex) {
		String merged = "";
		for (int i = startIndex; i < endIndex; i++) {
			String token = tokens[i];
			merged += token + " ";
		}
		return removeEndSpacesOrBrackets(merged);
	}

	String removeFrontZero(String token){
		if (token.startsWith(ZERO)) {
			return token.substring(1, token.length());
		}
		return token;
	}
	
	String removeEndSpacesOrBrackets(String token) {
		while (true){
			if (token.startsWith(" ") || token.startsWith("[")) {
				token = token.substring(1, token.length());
				continue;
			} 	
			if (token.endsWith(" ") || token.startsWith("]")) {
				token = token.substring(0, token.length()-1);
				continue;
			}
			return token;
		}
	}

	String removePluralOrPastTense(String token) {
		token = token.toLowerCase();
		if (token.length() > 1 && (token.endsWith("s") || token.endsWith("d"))) {
			token = token.substring(0, token.length()-1);
		}
		return token;
	}

	boolean isNumber(String token) {
		try {
			Integer.parseInt(token);
			return true;
		} catch (NumberFormatException e) {
			return false;
		}
	}

	boolean isCommandThatNoNeedContent(String token){
		return COMMANDS_NO_CONTENT.contains(token);
	}

	boolean isDominatingCommand(String token){
		return COMMANDS_DOMINATING.contains(token);
	}

	boolean isCommandThatNeedWords(String token) {
		return COMMANDS_NEED_WORDS.contains(token);
	}

	boolean isCommandButCannotBeInOneShot(String token) {
		return COMMANDS_NOT_ONE_SHOT.contains(token) || COMMANDS_NO_CONTENT.contains(token);
	}

	boolean hasOnlyOneWord(String s){
		return s.split(" ").length == 1;
	}
	
	boolean canBeSplit(String s1, String s2){
		return s1.split(s2).length > 1;
	}
	
	boolean isError(String content) {
		return content.equals(STATUS_ERROR);
	}

	boolean isErrorStatus(ArrayList<String> result) {
		return isError(getStatus(result));
	}

	boolean isParsingCompleted(ArrayList<String> result) {
		return !getStatus(result).equals(STATUS_INCOMPLETE);
	}
	
	void printParsingError(String src, String token, String dest){
		System.out.println(String.format("ParsingError: problem converting %1$s '%2$s' to %3$s", src, token, dest));
	}
	
	abstract ArrayList<String> makeErrorResult(ERROR error, String token);
}
```
###### src\main\java\backend\Parser\ParserVault.java
``` java
 */
public class ParserVault extends ParserSkeleton{
	
	private DateParser dateParser = new DateParser();

	//List of command words that have appeared in the parsed tokens
	private ArrayList<String> seenCommands = new ArrayList<String>();

	//Command words that only need the task's name/index, no other content needed
	private final ArrayList<String> COMMANDS_NEED_TASK_ONLY = new ArrayList<String>( Arrays.asList(
	COMMAND_ADD, COMMAND_DELETE, COMMAND_DONE) );
	
	//Variants or abbreviations of some of the command words
    private HashMap<String, ArrayList<String>> command_families = new HashMap<String, ArrayList<String>>(){
		static final long serialVersionUID = 1L; {
		put(COMMAND_DEADLINE, new ArrayList<String>( Arrays.asList("by", "dea")));
		put(COMMAND_DELETE, new ArrayList<String>( Arrays.asList("del")));
        put(COMMAND_DESCRIPTION, new ArrayList<String>( Arrays.asList("des")));
        put(COMMAND_EVENTSTART, new ArrayList<String>( Arrays.asList("from"))); 
        put(COMMAND_RECUR, new ArrayList<String>( Arrays.asList("recur", "recurring"))); 
        put(COMMAND_FILEPATH, new ArrayList<String>( Arrays.asList("fp")));
        put(COMMAND_PRIORITY, new ArrayList<String>( Arrays.asList("pri")));
        put(COMMAND_REMINDER, new ArrayList<String>( Arrays.asList("rem")));
    }};
	
    //All the fields that are used in ParserVault
	private final String FIELD_ALL = "all";
	private final String FIELD_RESULTTYPE = "resultType";
	private final String FIELD_TASK = "task";
	private final String FIELD_EVENTSTART = "eventStart";
	private final String FIELD_EVENTEND = "eventEnd";
	private final String FIELD_DESCRIPTION = COMMAND_DESCRIPTION;
	private final String FIELD_DEADLINE = COMMAND_DEADLINE;
	private final String FIELD_EVENT = COMMAND_EVENTSTART;
	private final String FIELD_PRIORITY = COMMAND_PRIORITY;
	private final String FIELD_REMINDER = COMMAND_REMINDER;
	private final String FIELD_RECUR = COMMAND_RECUR;
	private final String FIELD_RENAME = COMMAND_RENAME;
	private final String FIELD_RESET = COMMAND_RESET;
	private final String FIELD_DATE = "date";
	private final String FIELD_DATE_ABBR = "D";
	private final String FIELD_NAME = "name";
	private final String FIELD_NAME_ABBR = "N";
	private final String FIELD_PRIORITY_ABBR = "P";
	
	//The default list of fields and the order in which their contents are put into result
	private final ArrayList<String> FIELDS_DEFAULT = new ArrayList<String>( Arrays.asList(
	FIELD_RESULTTYPE, FIELD_TASK, FIELD_DESCRIPTION, FIELD_DEADLINE, FIELD_EVENTSTART, FIELD_EVENTEND, 
	FIELD_PRIORITY, FIELD_REMINDER, FIELD_RECUR, FIELD_RENAME ) ); 
	
	//List of fields that are used in the current result
	private ArrayList<String> fields = new ArrayList<String>(FIELDS_DEFAULT);
	
	//Stores the fields and their contents
	private HashMap<String, String> fieldContent = new HashMap<String, String>(){
		static final long serialVersionUID = 1L; {
		put(FIELD_RESULTTYPE, ""); put(FIELD_TASK, ""); put(FIELD_DESCRIPTION, ""); put(FIELD_DEADLINE, ""); 
		put(FIELD_EVENT, ""); put(FIELD_PRIORITY, ""); put(FIELD_REMINDER, ""); put(FIELD_RESET, "");
		put(FIELD_RECUR, ""); put(FIELD_RENAME, "");
	}};

	//Fields that can be reset
	private final ArrayList<String> FIELDS_CAN_RESET = new ArrayList<String>( 
	Arrays.asList(FIELD_ALL, FIELD_DESCRIPTION, FIELD_DATE, FIELD_DEADLINE, FIELD_RECUR, FIELD_EVENT, FIELD_PRIORITY, FIELD_REMINDER) );	
    
	//The task types that are recognised by Parser
	private final String TASKTYPE_TODO = "TODO";
	private final String TASKTYPE_EVENT = "EVENT";
	private final String TASKTYPE_FLOATING = "FLOATING";
	private final String TASKTYPE_OVERDUE = "OVERDUE";
	private final String TASKTYPE_TODAY = "TODAY";
	private final String TASKTYPE_DONE = "DONE";
	private final String TASKTYPE_COMPLETE = "COMPLETE";
	
	//The abbreviations (ABBR) of the task types
	private final String TASKTYPE_TODO_ABBR = "T";
	private final String TASKTYPE_EVENT_ABBR = "E";
	private final String TASKTYPE_FLOATING_ABBR = "F";
	private final String TASKTYPE_OVERDUE_ABBR = "O";
	private final String TASKTYPE_TODAY_ABBR = "D";
	private final String TASKTYPE_COMPLETE_ABBR = "C";
    
	/**
	 * This method marks the command as seen and sets the result type
	 */
	void storeCommand(String token) {
		String command = getContent(FIELD_RESULTTYPE);
		seenCommands.add(token);
	
		if (command.isEmpty()) {
			storeContent(FIELD_RESULTTYPE, token);
		} else if (!isCommandThatNeedTaskOnly(command)) {
			storeContent(FIELD_RESULTTYPE, RESULTTYPE_SET);
		}
	}

	/**
	 * This method stores the growing token into the field content and reset the growing token
	 */
	String storeToken(String token) {
		if (!token.isEmpty()) {
			token = removeEndSpacesOrBrackets(token);
			token = removeQuotes(token);
			String lastCommand = getLast(seenCommands);
			String field;
			
			if (getContent(FIELD_TASK).isEmpty()) {
				field = FIELD_TASK;
			} else if (isCommandThatNeedTaskOnly(lastCommand)) {
				field = FIELD_TASK;
			} else {
				field = lastCommand;
			}
			
			String content = getContent(field);
			if (content.isEmpty()) {
				storeContent(field, token);
			} else {
				storeContent(field, content + " " + token);
			}
		}
		return ""; //reset growingToken
	}

	void resetContents() {
		seenCommands.clear();
		fields = new ArrayList<String>(FIELDS_DEFAULT);
		for (String key: fieldContent.keySet()){
			storeContent(key, "");
		}
	}

	/**
	 * This methods checks if token is a command variant (if yes, convert it to the default command)
	 */
	String convertVariantToDefault(String token) {
		for (String command: COMMANDS) {
			if (token.equalsIgnoreCase(command)){
				return command;
			}
		}
		token = token.toLowerCase();
		for (String command: command_families.keySet()) {
			ArrayList<String> family = command_families.get(command);
			if (family.contains(token)) {
				return command;
			}
		}
		return token;
	}

	String getContent(String field) {
		return fieldContent.get(field);
	}
	
	String getContentOfCommand(String lastCommandSeen) {
		if (isCommandThatNeedTaskOnly(lastCommandSeen)) {
			return getContent(FIELD_TASK);
		} else {
			return getContent(lastCommandSeen);
		}
	}

	String getResultType() {
		return getContent(FIELD_RESULTTYPE);
	}
	
	String getLastSeenCommand(){
		return getLast(seenCommands);
	}

	boolean isSeenCommand(String token) {
		return seenCommands.contains(token);
	}
	
	ArrayList<String> makeCommandOnlyResult(String command){
		return new ArrayList<String>( Arrays.asList( command ) );
	}

	ArrayList<String> makeCommandWithContentResult(String command, String content){
		if (command.equals(COMMAND_SEARCH)) {
			content = parseSearchContent(content);
		}
		return new ArrayList<String>( Arrays.asList( command, content ) );
	}

	ArrayList<String> makeDominantResult(String firstWord, String secondWord, String content) {
		String command = firstWord;
		String index = secondWord;
		if (command.equals(COMMAND_SHOW)) {
			return makeShowResult(command, content);
		}
		if (command.equals(COMMAND_SORT)) {
			return makeSortResult(command, content);
		}
		if (command.equals(COMMAND_RESET)) {
			return makeResetResult(command, index, content);
		}
		if (isCommandThatNeedWords(command)) { //if first word is filepath or search
			return makeCommandWithContentResult(command, content);
		} else { //if first word is delete, done, or undone 
			if (isNumber(index)) {
				return makeCommandWithContentResult(command, index);
			} else {
				return makeErrorResult(ERROR.INVALID_INDEX, content);
			}
		}
	}

	/**
	 * This method creates a result that only has one field (for non one-shot commands)
	 */
	ArrayList<String> makeSingleFieldResult() {
		String resultType = getContent(FIELD_RESULTTYPE);
		String index = getContent(FIELD_TASK);
		String content = getContent(resultType);
		
		if (resultType.equals(FIELD_RECUR)) {
			return makeRecurringResult(resultType, index, content);
		} 	
		if (resultType.equals(FIELD_EVENT)) {
			return makeEventResult(resultType, index, content);
		}
		
		if (resultType.equals(FIELD_DEADLINE) || resultType.equals(FIELD_REMINDER)) {
			ArrayList<String> parseResult = makeDateResult(resultType, content);
			if (isErrorStatus(parseResult)) {
				return parseResult;
			}
			String parsedDate = getLast(parseResult);
			content = parsedDate;
		}
		if (resultType.equals(FIELD_PRIORITY) && isNotValidPriority(content)) {
			return makeErrorResult(ERROR.INVALID_PRIORITY, content);
		}
		return new ArrayList<String>( Arrays.asList(resultType, index, content) );
	}

	/**
	 * This method creates a result that has multiple fields (for one-shot commands)
	 */
	ArrayList<String> makeMultiFieldResult() {
		String resultType = getContent(FIELD_RESULTTYPE);
		String index = getContent(FIELD_TASK);
		String deadline = getContent(FIELD_DEADLINE);
		String event = getContent(FIELD_EVENT);
		String reminder = getContent(FIELD_REMINDER);
		String priority = getContent(FIELD_PRIORITY);
		String recur = getContent(FIELD_RECUR);
		if (resultType.equals(RESULTTYPE_ADD)) {
			fields.remove(FIELD_RENAME);
		}
		
		if (!priority.isEmpty() && isNotValidPriority(priority)) {
			return makeErrorResult(ERROR.INVALID_PRIORITY, priority);
		}
		if (!reminder.isEmpty()) {
			ArrayList<String> parseResult = makeDateResult(FIELD_REMINDER, reminder);
			if (isErrorStatus(parseResult)) {
				return makeErrorResult(ERROR.INVALID_DATE, reminder);
			}
		}
		if (!recur.isEmpty()) {
			if (deadline.isEmpty() && event.isEmpty() && resultType.equals(RESULTTYPE_ADD)) {
				return makeErrorResult(ERROR.NO_DATE_FOR_RECURRENCE, recur);
			}
			ArrayList<String> parsedResult = makeRecurringResult(resultType, index, recur);
			if (isErrorStatus(parsedResult)) {
				return parsedResult;
			} else {
				recur = getLast(parsedResult);
				storeContent(FIELD_RECUR, recur);
			}
		}
		if (!deadline.isEmpty() && !event.isEmpty()){
			return makeErrorResult(ERROR.CONFLICTING_DATES, event);
		}
		
		if (!deadline.isEmpty()) {
			return makeMultiFieldResultWithDeadline(resultType, deadline);
		} else if (!event.isEmpty()) {
			return makeMultiFieldResultWithEventDate(resultType, index, event);
		} else {
			if (resultType.equals(RESULTTYPE_ADD)) {
				resultType += TASKTYPE_FLOATING_ABBR;
				storeContent(FIELD_RESULTTYPE, resultType);
			}
			fields.remove(FIELD_DEADLINE);
			fields.remove(FIELD_EVENTSTART);
			fields.remove(FIELD_EVENTEND);
			return putFieldContentInResult();
		}
	}

	private void storeContent(String field, String content) {
		fieldContent.put(field, content);
	}

	private ArrayList<String> putFieldContentInResult() {
		ArrayList<String> result = new ArrayList<String>();
		for (String field: fields) {
			String content = getContent(field);
			result.add(content);
		}
		return result;
	}

	/**
	 * This method splits the event date/time to get the start and end date/time
	 * and stores them under separate fields
	 * @return the start and end date/time in an array
	 */
	private ArrayList<String> getEventStartAndEnd(String event) {
		String[] eventTokens = event.split(" " + COMMAND_EVENTEND + " ", 2);
		String eventStart = getFirst(eventTokens);
		String eventEnd = "";
		if (eventTokens.length > 1) {
			eventEnd = removeEndSpacesOrBrackets(getLast(eventTokens));
		}
		
		ArrayList<String> parsedStartResult = dateParser.parseEventStart(eventStart);
		if (isErrorStatus(parsedStartResult)) {
			return parsedStartResult;
		}
		eventStart = getLast(parsedStartResult);
		
		ArrayList<String> parsedEndResult = dateParser.parseEventEnd(eventStart, eventEnd);
		if (isErrorStatus(parsedEndResult)) {
			return parsedEndResult;
		}
		eventEnd = getLast(parsedEndResult);
		
		return new ArrayList<String>( Arrays.asList(eventStart, eventEnd));
	}

	private ArrayList<String> makeShowResult(String command, String content) {
		String taskType = getTaskType(content);
		if (isError(taskType)) {
			return makeErrorResult(ERROR.INVALID_TASKTYPE, content);
		} else {
			return new ArrayList<String>( Arrays.asList( command+taskType ) );
		}
	}

	private ArrayList<String> makeSortResult(String command, String content) {
		String field = getSortField(convertVariantToDefault(content));
		if (isError(field)) {
			return makeErrorResult(ERROR.INVALID_SORTFIELD, content);
		} else {
			return new ArrayList<String>( Arrays.asList( command+field ) );
		}
	}

	private ArrayList<String> makeResetResult(String command, String index, String content) {
		storeToken(index);
		storeCommand(command);
		String[] contentTokens = content.split(SPACE_OF_ANY_LENGTH);
		content = mergeTokens(contentTokens, 1, contentTokens.length);
		if (content.isEmpty()) {
			return makeErrorResult(ERROR.EMPTY_FIELD, command);
		} else {
			String fieldToReset = convertVariantToDefault(content);
			if (isCommandThatCanBeReset(fieldToReset)) {
				if (fieldToReset.equals(FIELD_DEADLINE) || fieldToReset.equals(FIELD_EVENT)) {
					fieldToReset = FIELD_DATE;
				}
				storeToken(fieldToReset);
				return makeSingleFieldResult();
			} else {
				return makeErrorResult(ERROR.INVALID_RESET, content);
			}
		}
	}

	private ArrayList<String> makeDateResult(String field, String date){
		ArrayList<String> dateValidity = dateParser.isInvalidDate(date);
		if (isErrorStatus(dateValidity)){
			return dateValidity;
		}
		if (dateParser.hasNoTime(date)) {
			if (field.equals(FIELD_DEADLINE)) {
				date += " " + DEFAULT_DEADLINE;
			} else if (field.equals(FIELD_REMINDER)){
				date += " " + DEFAULT_STARTTIME;
			}
		}
		
		String parsedDate = dateParser.parseDate(date);
		storeContent(field, parsedDate);
		return new ArrayList<String>( Arrays.asList(STATUS_OKAY, parsedDate));
	}

	private ArrayList<String> makeEventResult(String command, String index, String event) {
		if (event.endsWith(COMMAND_EVENTEND)) {
			return makeErrorResult(ERROR.NO_END_DATE, event);
		}
		ArrayList<String> parsedEvent = getEventStartAndEnd(event);
		if (isErrorStatus(parsedEvent)) {
			return parsedEvent;
		}
		
		String eventStart = getFirst(parsedEvent);
		String eventEnd = getLast(parsedEvent);
		storeContent(FIELD_EVENTSTART, eventStart);
		storeContent(FIELD_EVENTEND, eventEnd);
		
		return new ArrayList<String>( Arrays.asList(command, index, eventStart, eventEnd) );
	}

	private ArrayList<String> makeRecurringResult(String command, String name, String content){
		String interval = "";
		String freq = "";
		if (isNumber(getFirst(content))) {
			interval = getFirst(content);
			freq = getSecond(content);
		} else {
			interval = "1"; //eg. every day --> every 1 day
			freq = getFirst(content);
		}

		if (isNotValidFrequency(freq)) {
			return makeErrorResult(ERROR.INVALID_FREQUENCY, freq);
		}
		freq = removePluralOrPastTense(freq);
		return new ArrayList<String> ( Arrays.asList(command, name, interval + " " + freq) );
	}

	private ArrayList<String> makeMultiFieldResultWithDeadline(String resultType, String deadline) {
		resultType += TASKTYPE_TODO_ABBR;
		storeContent(FIELD_RESULTTYPE, resultType);
		fields.remove(FIELD_EVENTSTART);
		fields.remove(FIELD_EVENTEND);
		
		ArrayList<String> parseResult = makeDateResult(FIELD_DEADLINE, deadline);
		if (isErrorStatus(parseResult)) {
			return parseResult;
		}
		return putFieldContentInResult();
	}

	private ArrayList<String> makeMultiFieldResultWithEventDate(String resultType, String index, String event) {
		resultType += TASKTYPE_EVENT_ABBR;
		storeContent(FIELD_RESULTTYPE, resultType);
		fields.remove(FIELD_DEADLINE);
		
		ArrayList<String> parseResult = makeEventResult(FIELD_EVENTSTART, index, event);
		if (isErrorStatus(parseResult)) {
			return parseResult;
		}
		return putFieldContentInResult();
	}

	/**
	 * This method checks if any part of the search content can be interpreted as a date
	 * and convert that part into standardized date formats
	 */
	private String parseSearchContent(String content) {
		String[] contentTokens = content.split(SPACE_OF_ANY_LENGTH);
		String result = "";
		String date = "";
		for (String token: contentTokens) {
			if (isErrorStatus(dateParser.isInvalidDate(token))) {
				result += token + " ";
			} else {
				date += token + " ";
			}
		}
		if (!date.isEmpty()) {
			int dateLength = date.split(SPACE_OF_ANY_LENGTH).length;
			if (dateParser.isDayOfWeek(getFirst(date)) && dateParser.hasTime(date) && dateLength == 2) {
				date = dateParser.parseAndGetDayOfWeekAndTime(date); 
			} else if (dateParser.hasDate(date) && dateParser.hasTime(date)) {
				date = dateParser.parseDate(date);
			} else if (dateParser.isMonth(date) && dateLength == 1){
				date = dateParser.parseAndGetMonth(date);
			} else if (dateParser.isDayOfWeek(date) && dateLength == 1){
				date = dateParser.parseAndGetDayOfWeek(date);
			} else if (dateParser.hasDate(date)) {
				date = dateParser.parseAndGetDayAndMonth(date);
			} else if (dateParser.hasTime(date)) {
				date = dateParser.parseAndGetTime(date);
			}
		}
		return removeEndSpacesOrBrackets(result + date);
	}

	private boolean isCommandThatCanBeReset(String token) {
		return FIELDS_CAN_RESET.contains(token);
	}

	private boolean isCommandThatNeedTaskOnly(String token){
		return COMMANDS_NEED_TASK_ONLY.contains(token);
	}

	private boolean isNotValidPriority(String token){
		int priorityLevelMin = 1;
		int priorityLevelMax = 5;
		if (isNumber(token)) {
			int intToken = Integer.parseInt(token);
			if (intToken >= priorityLevelMin && intToken <= priorityLevelMax) {
				return false;
			}
			return true;
		}
		return true;
	}

	private boolean isNotValidFrequency(String token){
		token = removePluralOrPastTense(token);
		return !DATE_FREQUENCY.contains(token);
	}
	
	private String getTaskType(String token){
		token = removePluralOrPastTense(token);
		switch (token.toUpperCase()) {
			case TASKTYPE_TODO: 
			case TASKTYPE_TODO_ABBR:
				return TASKTYPE_TODO_ABBR;
			case TASKTYPE_EVENT:
			case TASKTYPE_EVENT_ABBR:
				return TASKTYPE_EVENT_ABBR;
			case TASKTYPE_FLOATING:
			case TASKTYPE_FLOATING_ABBR:
				return TASKTYPE_FLOATING_ABBR;
			case TASKTYPE_OVERDUE:
			case TASKTYPE_OVERDUE_ABBR:
				return TASKTYPE_OVERDUE_ABBR;
			case TASKTYPE_TODAY:
			case TASKTYPE_TODAY_ABBR:
				return TASKTYPE_TODAY_ABBR;
			case TASKTYPE_DONE:
			case TASKTYPE_COMPLETE:	
			case TASKTYPE_COMPLETE_ABBR:
				return TASKTYPE_COMPLETE_ABBR;
			default:
				return STATUS_ERROR;
		}
	}

	private String getSortField(String token){
		token = removePluralOrPastTense(token);
		switch (token) {
			case FIELD_DATE:
			case "by " + FIELD_DATE:
			case FIELD_DEADLINE:
			case "by " + FIELD_DEADLINE:
				return FIELD_DATE_ABBR;
			case FIELD_NAME:
			case "by " + FIELD_NAME:
				return FIELD_NAME_ABBR;
			case FIELD_PRIORITY:
			case "by " + FIELD_PRIORITY:
				return FIELD_PRIORITY_ABBR;
			default:
				switch (token.toUpperCase()) {
					case FIELD_DATE_ABBR:
						return FIELD_DATE_ABBR;
					case FIELD_NAME_ABBR:
						return FIELD_NAME_ABBR;
					case FIELD_PRIORITY_ABBR:
						return FIELD_PRIORITY_ABBR;
					default:
						return STATUS_ERROR;
				}
		}
	}

	private String removeQuotes(String token){
		if (token.startsWith(QUOTATION_MARK) && token.endsWith(QUOTATION_MARK)) {
			token =  token.substring(1, token.length()-1);
		} 
		return token;
	}
	
	@Override
	ArrayList<String> makeErrorResult(ERROR error, String token) {
		ArrayList<String> result = new ArrayList<String>(); 
		result.add(STATUS_ERROR);
		
		switch (error) {
			case INVALID_INDEX:
				result.add("InvalidIndexError: '" + token + "' is not recognised as an index");
				break;
			case EMPTY_FIELD:
				result.add("EmptyFieldError: Please enter content for the command '" + token + "'");
				break;
			case NO_END_DATE:
				result.add("NoEndDateError: Please enter an end date after the command word 'to'");
				break;
			case INVALID_PRIORITY:
				result.add("InvalidPriorityError: '" + token + "' is not between 1 to 5");
				break;
			case INVALID_DATE:
				result.add("InvalidDateError: '" + token + "' is not an acceptable date format");
				break;
			case CONFLICTING_DATES:
				result.add("ConflictingDatesError: Task cannot have both deadline and event date");
				break;
			case INVALID_FREQUENCY:
				result.add("InvalidFrequencyError: Please enter 'day'/'week'/'month'/'year' after 'every' to indicate the frequency");
				break;
			case INVALID_TASKTYPE:
				result.add("InvalidTaskTypeError: '" + token + "' is not a valid task type "
						+ "(please enter 'todo', 'event', 'floating', 'today', 'overdue' or 'complete')");
				break;
			case INVALID_SORTFIELD:
				result.add("InvalidSortFieldError: '" + token + "' is not a valid sort field "
						+ "(please enter 'date', 'name' or 'priority')");
				break;
			case INVALID_RESET:
				result.add("InvalidResetError: '" + token + "' is not a field that can be reset");
				break;
			case NO_DATE_FOR_RECURRENCE:
				result.add("NoDateForRecurrenceError: Cannot make floating task recur. Please set a deadline or start date for the task");
				break;
			default:
				break; 
		}
		return result;
	}
}
```
###### src\test\main\java\backend\Parser\ParserUnitTest.java
``` java
package main.java.backend.Parser;

import static org.junit.Assert.*;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;

import org.junit.Test;

/**
 * ParserTest
 * Contains the test cases for Parser component
```
###### src\test\main\java\backend\Parser\ParserUnitTest.java
``` java
 */
public class ParserUnitTest {
	public Parser parser = new Parser();
	String input;
	public ArrayList<String> actual; 
	public ArrayList<String> expected;
	
	private void printTest() {
		System.out.println("Input:    " + input);
	    System.out.println("Expected: " + expected.toString());
	    System.out.println("Actual:   " + actual.toString());
	}
	
	private void executeTest() {
		printTest();
	    assertEquals(expected, actual);
	}

	private String getTodayDate() {
		SimpleDateFormat sdfDate = new SimpleDateFormat("EEE, dd MMM");
	    Date now = new Date();
	    String strDate = sdfDate.format(now);
		return strDate;
	}
	
	private String getTmrDate() {
		SimpleDateFormat sdfDate = new SimpleDateFormat("EEE, dd MMM");
	    Date now = new Date();
	    long milliNow = now.getTime();
	    long milliTmr = milliNow += (1000 * 60 * 60 * 24);
	    String strDate = sdfDate.format(milliTmr);
		return strDate;
	}
	
	@Test
	/**
	 * Test whether basic commands with valid inputs work
	 */
	public void BasicTests() {
		System.out.println("\n-----------------Result for BasicTests-----------------");
		
	    input = "exit";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("exit") );
	    executeTest();
	   
	    input = "redo";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("redo") );
	    executeTest();
	    
	    input = "deleteall";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deleteAll") );
	    executeTest();
	    
		input = "add Project Proposal";
		actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addF", "Project Proposal", "", "", "", "") );
	    executeTest();
	    
	    input = "1 deadline 30 December 23:59";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 11:59pm") );
	    executeTest();
	    
	    input = "1 priority 5";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("priority", "1", "5") );
	    executeTest();
	    
	    input = "1 description i need to start doing this!";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("description", "1", "i need to start doing this!") );
	    executeTest();
	    
	    input = "ADD PROJECT PROPOSAL";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addF", "PROJECT PROPOSAL", "", "", "", "") );
	    executeTest();
	    
	    input = "1     deadline     30  December     23:59";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 11:59pm") );
	    executeTest();
	    
	    input = "1 by 12 Feb 3pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Fri, 12 Feb 16, 3pm") );
	    executeTest();
	    
	    input = "1 BY 12 Feb 3pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Fri, 12 Feb 16, 3pm") );
	    executeTest();
	    
	    input = "3 from 4 Apr 4pm to 5 May 5:30pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "3", "Mon, 04 Apr 16, 4pm", "Thu, 05 May 16, 5:30pm") );
	    executeTest();
	   
	    input = "4 rename new task name";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("rename", "4", "new task name") );
	    executeTest();
	    
	    input = "showF";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("showF") );
	    executeTest();
	    
	    input = "showO";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("showO") );
	    executeTest();
	    
	    input = "show floating";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("showF") );
	    executeTest();
	    	    
	    input = "show events";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("showE") );
	    executeTest();
	    
	    input = "show today";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("showD") );
	    executeTest();
	    
	    input = "show d";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("showD") );
	    executeTest();
	    
	    input = "show done";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("showC") );
	    executeTest();
	    
	    input = "show completed";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("showC") );
	    executeTest();
	    
	    input = "SHOW COMPLETED";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("showC") );
	    executeTest();
	    
	    input = "sortp";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("sortP") );
	    executeTest();
	    
	    input = "sort date";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("sortD") );
	    executeTest();
	    
	    input = "sort deadline";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("sortD") );
	    executeTest();
	    
	    input = "sort pri";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("sortP") );
	    executeTest();
	    
	    input = "sort name";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("sortN") );
	    executeTest();
	    
	    input = "sort by priority";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("sortP") );
	    executeTest();
	    
	    input = "sort N";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("sortN") );
	    executeTest();
	    
	    input = "search meeting with boss";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("search", "meeting with boss") );
	    executeTest();
	    
	    input = "filepath Desktop/TankTask/";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("filepath", "Desktop/TankTask/") );
	    executeTest();
	    
	    input = "fp Desktop/TankTask/";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("filepath", "Desktop/TankTask/") );
	    executeTest();
	}
	
	@Test
	/**
	 * Test whether dominating commands work properly
	 */
	public void DominatingCommands() {
		System.out.println("\n-----------------Result for DominatingCommands-----------------");
		
		//should ignore the extra words
	    input = "exit extra extra extra words";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("exit") );
	    executeTest();
	    
	    //either format for done/delete should work
	    input = "done 1";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("done", "1") );
	    executeTest();
	    
	    input = "1 done";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("done", "1") );
	    executeTest();
	    
	    //dominating commands should be ignored when 'add' is in effect
	    input = "Add Project Proposal done delete";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addF", "Project Proposal done delete", "", "", "", "") );
	    executeTest();
	    
	    input = "add Project Proposal search";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addF", "Project Proposal search", "", "", "", "") );
	    executeTest();
	    
	    //all other commands should be ignored when 'search' is in effect
	    input = "search Project Proposal description bla bla every week";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("search", "Project Proposal description bla bla every week") );
	    executeTest();
	    
	    //'addcat' should be ignored when 'add' is in effect
	    input = "add Project Proposal addcat priority 5";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addF", "Project Proposal addcat", "", "5",
	    												"", "") );
	    executeTest();
	    
	    //all dominating commands and no-content commands should be ignored when 'add' is in effect
	    input = "add addcat delete search reset sortp exit showf";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addF", "addcat delete search reset sortp exit showf", "", "", "", "") );
	    executeTest();
	    
	    //delete/done should ignore extra words
	    input = "delete 1 aaaaaaaaaa";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("delete", "1") );
	    executeTest();
	    
	    //Test whether reset works properly
	    input = "1 reset all";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("reset", "1", "all") );
	    executeTest();
	    
	    input = "1 reset deadline";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("reset", "1", "date") );
	    executeTest();
	    
	    input = "1 reset event";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("reset", "1", "date") );
	    executeTest();
	    
	    input = "1 reset DATE";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("reset", "1", "date") );
	    executeTest();
	    
	    input = "1 reset priority";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("reset", "1", "priority") );
	    executeTest();
	    
	    input = "1 reset pri";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("reset", "1", "priority") );
	    executeTest();
	    
	    //If last word is a commad keyword and 'add' is in effect, the last command keyword is taken as part of task name
	    input = "add bla deadline";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addF", "bla deadline", "", "", "", "") );
	    executeTest();
	    
	    input = "1 des bla bla deadline";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("description", "1", "bla bla deadline") );
	    executeTest();
	}
	
	@Test
	/**
	 * Test whether one-shot commands work properly
	 */
	public void OneShotCommand() {
		System.out.println("\n-----------------Result for OneShotCommand-----------------");
	    
		//Check that you can add floatings with one-shot commands
		input = "add Project Proposal priority 5";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addF", "Project Proposal", "", "5", "", "") );
	    executeTest();
	    
	    input = "add User Guide reminder 20 December 12:00 description i will do this in 10 days priority 3";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addF", "User Guide", "i will do this in 10 days", "3", 
	    												"Sun, 20 Dec 15, 12pm", "") );
	    executeTest();
	    
	    //Check that you can add to-dos with one-shot commands
	    input = "add Project Proposal deadline 30 December 23:59";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addT", "Project Proposal", "", "Wed, 30 Dec 15, 11:59pm", "", "", "") );
	    executeTest();
	    
	    input = "add Project Proposal deadline 30 December 23:59 priority 5 description i need to start doing this!";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addT", "Project Proposal", "i need to start doing this!",  
	    								  "Wed, 30 Dec 15, 11:59pm", "5", "", "") );
	    executeTest();  
	    
	    //Check that you can add events with one-shot commands
	    input = "add OP2 event 29 Dec 2pm to 3pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addE", "OP2", "", "Tue, 29 Dec 15, 2pm", "Tue, 29 Dec 15, 3pm", "", "", "") );
	    executeTest();
	    
	    //Check that you can set multiple fields for existing tasks 
	    input = "1 description i must finish this early reminder 25 Dec 21:00";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("set", "1", "i must finish this early", "", 
	    												"Fri, 25 Dec 15, 9pm", "", "") );
	    executeTest();
	    
	    input = "2 priority 4 deadline 5 October 20:00 every day ";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("setT", "2", "", "Wed, 05 Oct 16, 8pm",
	    												"4", "", "1 day", "") );
	    executeTest();
	    
	    input = "2 priority 4 every day";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("set", "2", "", "4", "", "1 day", "") );
	    executeTest();
	    
	    input = "3 deadline 19 Nov 3pm every 6 months";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("setT", "3", "", "Thu, 19 Nov 15, 3pm", 
													"", "", "6 month", "") );
	    executeTest();
	    
	    //Check that command shortforms also work for one-shot commands
	    input = "1 des hello dea 11 Jan 2pm rem 5 Jan 2pm pri 2";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("setT", "1", "hello", "Mon, 11 Jan 16, 2pm", "2", "Tue, 05 Jan 16, 2pm", "", "") );
	    executeTest();
	    
	    input = "1 des hello rename bla bla pri 2";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("set", "1", "hello", "2", "", "", "bla bla") );
	    executeTest();
	    
	    //Test recurring in one-shot command
	    input = "add daily task from 20 dec 2pm to 4pm every day";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addE", "daily task", "", "Sun, 20 Dec 15, 2pm", "Sun, 20 Dec 15, 4pm", "", "", "1 day") );
	    executeTest();
	    
	    input = "add weekly task by friday 5pm every week";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addT", "weekly task", "", "Fri, 06 Nov 15, 5pm", "Sun, 20 Dec 15, 4pm", "", "", "1 week") );
	    printTest();
	    
	    input = "add monthly task from 30 dec every 2 months";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addE", "monthly task", "", "Wed, 30 Dec 15, 9am", "Wed, 30 Dec 15, 9pm", "", "", "2 month") );
	    executeTest();
	}
	
	@Test
	/**
	 * Test whether parser can ignore Duplicate commands in certain scenarios
	 */
	public void DuplicateCommands() {
		System.out.println("\n-----------------Result for DuplicateCommands-----------------");
	    
		//Test whether Duplicate 'add' is considered as part of task name
	    input = "add add";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addF", "add", "", "", "", "") );
	    executeTest();
	    
	    input = "add add food to the fridge priority 2";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addF", "add food to the fridge", "", "2", "", "") );
	    executeTest();
	    
	    //Test whether Duplicate 'description' is considered as part of description
	    input = "1 description hello this is a description";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("description", "1", "hello this is a description") );
	    executeTest();
	    
	    input = "1 description hello this is a description priority 3";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("set", "1", "hello this is a description", "3", "", "", "") );
	    executeTest();
	    
	    //Test whether other Duplicate commands are considered as part of description (when description is in effect)
	    input = "1 deadline 15 dec 10pm every day des i do this every day";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("setT", "1", "i do this every day", "Tue, 15 Dec 15, 10pm", "", "", "1 day", "") );
	    executeTest();
	    
	    //Test whether command keywords inside quotations will be ignored
	    input = "1 des buy from every pet shop";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "EmptyFieldError: Please enter content for the command 'event'") );
	    executeTest();
	    
	    input = "1 des \"buy cat from pet shop\"";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("description", "1", "buy cat from pet shop") );
	    executeTest();
	    
	    input = "add \"buy new cat\" des \"buy cat from pet shop\"";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addF", "buy new cat", "buy cat from pet shop", "", "", "") );
	    executeTest();
	    
	    input = "add \"buy new cat\" pri 3 rem 21 Jul 7pm des \"buy cat from pet shop\"";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addF", "buy new cat", "buy cat from pet shop", "3", "Thu, 21 Jul 16, 7pm", "") );
	    executeTest();
	    
	    input = "add \"buy new cat\" rem 21 Jul 7pm des \"buy cat from pet shop\" pri 3";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addF", "buy new cat", "buy cat from pet shop", "3", "Thu, 21 Jul 16, 7pm", "") );
	    executeTest();
	    
	    input = "1 des \"buy new pet";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("description", "1", "\"buy new pet") );
	    executeTest();
	    
	    input = "1 des \"buy\"";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("description", "1", "buy") );
	    executeTest();
	    
	    input = "1 des \"buy cat\" pet";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("description", "1", "\"buy cat\" pet") );
	    executeTest();
	    
	    //Ignore duplicate when user types 'recur every'
	    input = "2 recur week";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "2", "1 week") );
	    executeTest();
	    
	    input = "2 recur every week";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "2", "1 week") );
	    executeTest();
	    
	    input = "2 recurring every 3 weeks";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "2", "3 week") );
	    executeTest();
	}

	@Test
	/**
	 * Test whether date and time are being formatted correctly
	 */
	public void DateAndTime(){
		System.out.println("\n-----------------Result for DateAndTime-----------------");
		
		//Testing different deadline formats for the same date and time
		input = "1 deadline 30/12/15 23:59";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 11:59pm") );
	    executeTest();
	    
		input = "1 deadline 30-12-15 23.59";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 11:59pm") );
	    executeTest();
	    
		input = "1 deadline 30/12 11:59pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 11:59pm") );
	    executeTest();
	    
		input = "1 deadline 30/12 23:59";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 11:59pm") );
	    executeTest();
	    
		input = "1 deadline 30 Dec 23:59";
		actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 11:59pm") );
	    executeTest();
	    
		input = "1 deadline 30 Dec 8:07pm";
		actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 8:07pm") );
	    executeTest();
	    
	    //Test whether time without minutes work
		input = "1 deadline 30-12 11pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 11pm") );
	    executeTest();
	    
	    //Test whether a full date and time works
		input = "1 deadline 12/3/2016 04:56";
		actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Sat, 12 Mar 16, 4:56am") );
	    executeTest();
	    
	    //Test whether deadline without time is given the default time 11:59pm
		input = "1 deadline 30/12";
		actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 11:59pm") );
	    executeTest();
	    
		input = "1 deadline 30 Dec";
		actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 11:59pm") );
	    executeTest();
	    
		input = "1 deadline December 30";
		actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 11:59pm") );
	    executeTest();
	    
	    //The result of these tests depend on whether the current time is before or after the stated deadline
		/*input = "1 deadline 2:30pm";
		actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", dateTmr + " 14:30:00 " + yearNow) );
	    printTest();
	    
		input = "1 deadline 20:00";
		actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", dateNow + " 20:00:00 " + yearNow) );
	    printTest();*/
	    
	    //Testing if zeroes are removed correctly from time
		input = "1 deadline 30 Dec 8pm";
		actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 8pm") );
	    executeTest();
	    
		input = "1 deadline 30 Dec 8:07pm";
		actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 8:07pm") );
	    executeTest();
	    
		input = "1 deadline 30 Dec 8:10pm";
		actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 8:10pm") );
	    executeTest();
	    
	    //Testing for event with both start and end date/time
	    input = "3 event 15/09 10:00 to 17/09 09:59";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "3", "Thu, 15 Sep 16, 10am", 
	    "Sat, 17 Sep 16, 9:59am") );
	    executeTest();
	    
	    input = "4 event 15/09 10AM to 16/09 11AM";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 10am", "Fri, 16 Sep 16, 11am") );
	    executeTest();
	    
	    //Testing for event with end date but not time (should set the end time to be same as start time)
	    input = "4 event 15/09 10am to 16/09";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 10am", "Fri, 16 Sep 16, 9pm") );
	    executeTest();
	    
	    input = "4 event 15 Sep 10am to 16 Sep";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 10am", "Fri, 16 Sep 16, 9pm") );
	    executeTest();
	    
	    input = "4 event 15 September 10am to 16 September";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 10am", "Fri, 16 Sep 16, 9pm") );
	    executeTest();
	    
	    //Testing for when end date is before start date (should set it to one day or one year later)
	    input = "4 event 15 Sep 10am to 14 Sep";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 10am", "Thu, 14 Sep 17, 9pm") );
	    executeTest();
	    
	    input = "4 event 15 Sep 10:30am to 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 10:30am", "Fri, 16 Sep 16, 10am") );
	    executeTest();
	    
	    input = "4 event 15 Sep 10:30am to 10:10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 10:30am", "Fri, 16 Sep 16, 10:10am") );
	    executeTest();
	    
	    input = "4 event 15 Sep 10am to 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 10am", "Fri, 16 Sep 16, 10am") );
	    executeTest();
	    
	    input = "2 event 15 Sep 2pm to 15 Sep 1pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "2", "Thu, 15 Sep 16, 2pm", "Fri, 15 Sep 17, 1pm") );
	    executeTest();
	   
	    //Testing for event with end time but not date (should set end date to be the same day or the next day depending on time)
	    input = "4 event 15/09 10am to 2pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 10am", "Thu, 15 Sep 16, 2pm") );
	    executeTest();
	    
	    input = "4 event 15/09 10am to 8am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 10am", "Fri, 16 Sep 16, 8am") );
	    executeTest();
	    
	    input = "4 event 15/09 2am to 4am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 2am", "Thu, 15 Sep 16, 4am") );
	    executeTest();
	    
	    input = "4 event 15/09 12pm to 12pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 12pm", "Fri, 16 Sep 16, 12pm") );
	    executeTest();
	    
	    input = "4 event 15 Sep 10:30am to 10:45am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 10:30am", "Thu, 15 Sep 16, 10:45am") );
	    executeTest();

	    input = "4 event 15/09 11:55PM to 11:59PM";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 11:55pm", "Thu, 15 Sep 16, 11:59pm") );
	    executeTest();
	    
	    //Testing for event with no end date/time (should set end date to be same as start date, time to be 11:59pm)
	    input = "2 event 15/09 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "2", "Thu, 15 Sep 16, 10am", "Thu, 15 Sep 16, 9pm") );
	    executeTest();
	    
	    input = "2 event 15 Sep 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "2", "Thu, 15 Sep 16, 10am", "Thu, 15 Sep 16, 9pm") );
	    executeTest();
	    
	    //Testing for event with no start or end time (set both to 9am)
	    input = "2 event 15 Sep to 16 Sep";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "2", "Thu, 15 Sep 16, 9am", "Fri, 16 Sep 16, 9pm") );
	    executeTest();
	   
	    //Testing for when time was entered before date
		input = "1 deadline 3pm 30 Dec";
		actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Wed, 30 Dec 15, 3pm") );
	    executeTest();
	    
	    input = "4 event 10am 15/09 to 16/09";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 10am", "Fri, 16 Sep 16, 9pm") );
	    executeTest();
	    
	    input = "4 event 10am 15 Sep to 14 Sep";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 10am", "Thu, 14 Sep 17, 9pm") );
	    executeTest();
	    
	    input = "4 event 10:30am 15 Sep to 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 10:30am", "Fri, 16 Sep 16, 10am") );
	    executeTest();
	    
	    input = "4 event 10am 15/09 to 8am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Thu, 15 Sep 16, 10am", "Fri, 16 Sep 16, 8am") );
	    executeTest();
	    input = "2 event 10am 15/09";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "2", "Thu, 15 Sep 16, 10am", "Thu, 15 Sep 16, 9pm") );
	    executeTest();
	   
	    //Testing event in one-shot commands (some with year specified, some without)
	    input = "2 description i must reach there early event 30/12 11am to 3pm reminder 29/12/15 12:00";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("setE", "2", "i must reach there early", 
	    "Wed, 30 Dec 15, 11am", "Wed, 30 Dec 15, 3pm", "", "Tue, 29 Dec 15, 12pm", "", "") );
	    executeTest();
	    
	    input = "add 2101 meeting event 12/12/15 12:00 to 18:00 priority 3";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addE", "2101 meeting", "", "Sat, 12 Dec 15, 12pm", 
	    "Sat, 12 Dec 15, 6pm", "3", "", "") );
	    executeTest();
	       
	    input = "add 2101 meeting event Dec 12 12:00 to 18:00 priority 3";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addE", "2101 meeting", "", "Sat, 12 Dec 15, 12pm", 
	    "Sat, 12 Dec 15, 6pm", "3", "", "") );
	    executeTest();
	    
	    input = "add 2101 meeting event 12 Dec 2015 12:00 to 18:00 priority 3";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addE", "2101 meeting", "", "Sat, 12 Dec 15, 12pm", 
	    										"Sat, 12 Dec 15, 6pm", "3", "", "") );
	    executeTest();
	    
	    input = "add 2101 meeting event Dec 12 12:00 to 12 Dec 18:00 priority 3";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addE", "2101 meeting", "", "Sat, 12 Dec 15, 12pm", 
	    										"Sat, 12 Dec 15, 6pm", "3", "", "") );
	    executeTest();
	    
	    input = "add longest meeting ever event Dec 12 2015 12:00 to Dec 12 2016 18:00 priority 3";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addE", "longest meeting ever", "", "Sat, 12 Dec 15, 12pm", 
	    										"Mon, 12 Dec 16, 6pm", "3", "", "") );
	    executeTest();
	    
	    input = "add longest meeting ever event 12/12/15 12:00 to 12/12/16 18:00 priority 3";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("addE", "longest meeting ever", "", "Sat, 12 Dec 15, 12pm", 
	    										"Mon, 12 Dec 16, 6pm", "3", "", "") );
	    executeTest();
	    
	    //Test whether parser will change an old year to the current year
	    input = "2 by 31 Dec 1995 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "2", "Thu, 31 Dec 15, 10am") );
	    executeTest();
	    
		input = "1 deadline 12/3/2014 9pm";
		actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "1", "Sat, 12 Mar 16, 9pm") );
	    executeTest();
	   
	    //Test when year is not specified, whether parser can set the date to always be the nearest one in the future
	    input = "2 event 31 Dec 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "2", "Thu, 31 Dec 15, 10am", "Thu, 31 Dec 15, 9pm") );
	    executeTest();
	    
	    input = "2 event 2 Jan 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "2", "Sat, 02 Jan 16, 10am", "Sat, 02 Jan 16, 9pm") );
	    executeTest();
	   
	    //Test when only event start date is specified, whether parser can set start time to default 12pm, and end date/time to default too
	    input = "2 event 2 Jan";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "2", "Sat, 02 Jan 16, 9am", "Sat, 02 Jan 16, 9pm") );
	    executeTest();
	    
	    //Test whether extra spaces affect date parser
	    input = "2 by 2 Jan 10 am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "2", "Sat, 02 Jan 16, 10am") );
	    executeTest();
	    
	    input = "2 from 2 Jan 10 am to 10 pm ";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "2", "Sat, 02 Jan 16, 10am", "Sat, 02 Jan 16, 10pm") );
	    executeTest();
	    
	    input = "2 from 2 Jan 10 am to 3/1 10 pm ";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "2", "Sat, 02 Jan 16, 10am", "Sun, 03 Jan 16, 10pm") );
	    executeTest();
	    
	    input = "2 by Jan 2 10:30 am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "2", "Sat, 02 Jan 16, 10:30am") );
	    executeTest();
	    
	    input = "2 from Jan 2 10:24 am to 3 Feb 7:39 pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "2", "Sat, 02 Jan 16, 10:24am", "Wed, 03 Feb 16, 7:39pm") );
	    executeTest();
	    
	    //Test whether lack of spaces affect date parser
	    input = "2 by 2Jan 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "2", "Sat, 02 Jan 16, 10am") );
	    executeTest();
	    
	    input = "2 by 30Jun 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "2", "Thu, 30 Jun 16, 10am") );
	    executeTest();
	    
	    input = "2 by Jan2 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "2", "Sat, 02 Jan 16, 10am") );
	    executeTest();
	    
	    input = "2 from Jan2 10am to 5Jun 10pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "2", "Sat, 02 Jan 16, 10am", "Sun, 05 Jun 16, 10pm") );
	    executeTest();
	    
	    input = "2 from 2January 10am to June5 10pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "2", "Sat, 02 Jan 16, 10am", "Sun, 05 Jun 16, 10pm") );
	    executeTest();
	    
	    //Test whether shortform for deadline works
	    input = "3 by today";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "3", getTodayDate() + " 15, 11:59pm") );
	    executeTest();
	    
	    input = "3 by tmr";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "3", getTmrDate() + " 15, 11:59pm") );
	    executeTest();
	    
	    //Test whether daily recurring task works
	    input = "5 every day";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "5", "1 day") );
	    executeTest();
	    
	    input = "5 every 3 days";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "5", "3 day") );
	    executeTest();
	    	    
	    //Test whether weekly recurring task works
	    input = "5 every 1 week";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "5", "1 week") );
	    executeTest();
	    
	    input = "5 every week";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "5", "1 week") );
	    executeTest();
	    
	    input = "5 every 2 WEEKS";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "5", "2 week") );
	    executeTest();
	    
	    //Test whether monthly recurring task works
	    input = "5 every month";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "5", "1 month") );
	    executeTest();
	    
	    input = "5 every 3 months";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "5", "3 month") );
	    executeTest();
	    
	    input = "5 every month aaaaa";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "5", "1 month") );
	    executeTest();
	    
	    //Test whether yearly recurring task works
	    input = "5 every year";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "5", "1 year") );
	    executeTest();
	    
	    input = "5 every 10 years";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "5", "10 year") );
	    executeTest();
	    
	    input = "5 every 100 years";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "5", "100 year") );
	    executeTest();
	    
	    //Test if using 'next' or 'later' works
	    input = "6 by 10 days later 2pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "5", "01 Apr") );
	    printTest();

	    input = "6 by next tue 3pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "5", "01 Apr") );
	    printTest();
	    
	    input = "6 by 2 wed later 4pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("every", "5", "01 Apr") );
	    printTest();
	    
	    input = "search 12 feb 2pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("search", "Fri, 12 Feb 16, 2pm") );
	    executeTest();
	    
	    input = "search 12 feb";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("search", "12 Feb") );
	    executeTest();
	    
	    input = "search 12/2";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("search", "12 Feb") );
	    executeTest();
	    
	    input = "search 2pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("search", "2pm") );
	    executeTest();
	    
	    input = "search 14:30";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("search", "2:30pm") );
	    executeTest();
	    
	    input = "search saturday";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("search", "Sat") );
	    executeTest();
	    
	    input = "search fri";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("search", "Fri") );
	    executeTest();
	    
	    input = "search saturday 14:00";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("search", "Sat 2pm") );
	    executeTest();
	    
	    input = "search today";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("search", "") );
	    printTest();
	    
	    input = "search next sat 2pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("search", "") );
	    printTest();
	    
	    input = "search Sunday guitar lesson";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("search", "guitar lesson Sun") );
	    executeTest();
	    
	    input = "search november";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("search", "Nov") );
	    executeTest();
	    
	    //Test whether add20ToYear works
	    input = "4 by 15/09/17 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "4", "Fri, 15 Sep 17, 10am") );
	    executeTest();
	    
	    input = "4 by 15 sep 18 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "4", "Sat, 15 Sep 18, 10am") );
	    executeTest();
	    
	    input = "4 by sep 15 27 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "4", "Wed, 15 Sep 27, 10am") );
	    executeTest();
	    
	    input = "4 from dec 22 10";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "4", "Tue, 22 Dec 15, 9am", "Tue, 22 Dec 15, 9pm") );
	    executeTest();
	    
	    //Test whether confirmDateIsInfuture works properly
	    input = "2 from 7 nov 10 12pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "2", "Mon, 07 Nov 16, 12pm", "Mon, 07 Nov 16, 9pm") );
	    printTest();
		
	    input = "2 from 7 nov 10 5pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("event", "2", "Sat, 07 Nov 15, 5pm", "Sat, 07 Nov 15, 9pm") );
	    printTest();
	    
	    //Make sure 'today' works for events
	    input = "3 from today 10pm to today 11pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "3", getTodayDate() + " 15, 10pm", getTodayDate() + " 15, 11pm") );
	    printTest();
	    
	    input = "3 from today 8am to today 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("deadline", "3", getTodayDate() + " 15, 8am", getTodayDate() + " 15, 10am") );
	    printTest();
	}
	
	@Test
	/**
	 * Test whether parser can handle invalid commands
	 */
	public void ErrorTests(){
		System.out.println("\n-----------------Result for ErrorTests-----------------");
		
		//Parser should generate error if first word is not a command keyword or index
	    input = "addd Project Proposal";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidWordError: 'addd' is not recognised as a command or index") );
	    executeTest();
	    
		input = "Project Proposal done";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidWordError: 'Project' is not recognised as a command or index") );
	    executeTest();
	    
	    //Parser should generate error if task index is not followed by a command keyword
		input = "1 bla";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidCommandError: 'bla' is not recognised as a command") );
	    executeTest();
	    
		input = "1";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "NoCommandError: Please enter a command after the task index '1'") );
	    executeTest();
	    	    
	    //Parser should generate error when a command is expecting an index, but the next word(s) is not an index
	    input = "delete Project Proposal";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidIndexError: 'Project Proposal' is not recognised as an index") );
	    executeTest();
	   
	    //Parser should generate error when Duplicate commands are detected
		input = "1 deadline 30 October 12:34 deadline 30 December 23:59";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "DuplicateCommandError: Duplicate command 'deadline'") );
	    executeTest();
	    
		input = "1 priority 1 priority 5 priority 3";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "DuplicateCommandError: Duplicate command 'priority'") );
	    executeTest();
	    
		input = "add Project Proposal deadline coming soon priority 2 deadline 30 Nov 23:59";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "DuplicateCommandError: Duplicate command 'deadline'") );
	    executeTest();
	    
	    //Parser should generate error when user never include the content for a command
	    input = "deadline";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "EmptyFieldError: Please enter content for the command 'deadline'") );
	    executeTest();
	    
	    input = "deadline deadline";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "EmptyFieldError: Please enter content for the command 'deadline'") );
	    executeTest();
	    
	    input = "add";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "EmptyFieldError: Please enter content for the command 'add'") );
	    executeTest();
	    
	    input = "done";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "EmptyFieldError: Please enter content for the command 'done'") );
	    executeTest();
	    
	    input = "1 priority";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "EmptyFieldError: Please enter content for the command 'priority'") );
	    executeTest();
	    
	    input = "1 priority 3 deadline description hello";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "EmptyFieldError: Please enter content for the command 'deadline'") );
	    executeTest();
	    
	    input = "add dea des pri cat";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "EmptyFieldError: Please enter content for the command 'add'") );
	    executeTest();
	    
	    input = "show";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "EmptyFieldError: Please enter content for the command 'show'") );
	    executeTest();
	    
	    input = "1 reset";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "EmptyFieldError: Please enter content for the command 'reset'") );
	    executeTest();
	    
	    //Parser should generate error if priority is invalid (not between 1 to 5)
	    input = "1 priority 6";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidPriorityError: '6' is not between 1 to 5") );
	    executeTest();
	    
	    input = "1 priority bla";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidPriorityError: 'bla' is not between 1 to 5") );
	    executeTest();
	    
	    input = "1 deadline 30 Dec 23:59 priority 0";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidPriorityError: '0' is not between 1 to 5") );
	    executeTest();

	    //Parser should generate error when a date cannot be actual
	    input = "1 deadline qwertyuiop";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidDateError: 'qwertyuiop' is not an acceptable date format") );
	    executeTest();
	    
	    input = "1 priority 2 deadline qwertyuiop";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidDateError: 'qwertyuiop' is not an acceptable date format") );
	    executeTest();
	    
	    input = "1 reminder qwertyuiop";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidDateError: 'qwertyuiop' is not an acceptable date format") );
	    executeTest();
	    input = "1 reminder qwertyuiop priority 2";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidDateError: 'qwertyuiop' is not an acceptable date format") );
	    executeTest();
	    
	    input = "1 event qwertyuiop";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidDateError: 'qwertyuiop' is not an acceptable date format") );
	    executeTest();
	    
	    input = "1 event asdfghjkl to 30 Dec 2pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidDateError: 'asdfghjkl' is not an acceptable date format") );
	    executeTest();
	    
	    input = "1 event 30 Dec 2pm 2015 to asdfghjkl";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidDateError: 'asdfghjkl' is not an acceptable date format") );
	    executeTest();
	    
	    //Parser should not allow a task to have both deadline and event date
	    input = "1 deadline 15 Dec 8pm event 30 Dec 2pm to 6pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "ConflictingDatesError: Task cannot have both deadline and event date") );
	    executeTest();
	    
	    input = "1 des conflicting dates deadline 15 Dec 8pm pri 4 event 30 Dec 2pm to 6pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "ConflictingDatesError: Task cannot have both deadline and event date") );
	    executeTest();
	    
	    input = "1 event 30 Dec 2pm to";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "NoEndDateError: Please enter an end date after the command word 'to'") );
	    executeTest();
	    
	    input = "1 event 30 Dec 2pm to rem 23 Dec 2pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "NoEndDateError: Please enter an end date after the command word 'to'") );
	    executeTest();
	    
	    //Parser should generate error when user never indicate the frequency of a recurring task
	    input = "5 every 2pm 2015";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidFrequencyError: Please enter 'day'/'week'/'month'/'year' after 'every' to indicate the frequency") );
	    executeTest();
	    
	    input = "5 every time Tue 12pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidFrequencyError: Please enter 'day'/'week'/'month'/'year' after 'every' to indicate the frequency") );
	    executeTest(); 
	    
	    //Parser should generate error when the content to show/sort/reset is invalid
	    input = "show aaaaa";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidTaskTypeError: 'aaaaa' is not a valid task type "
	    		+ "(please enter 'todo', 'event', 'floating', 'today', 'overdue' or 'complete')" ) );
	    executeTest();
	    
	    input = "sort aaaaa";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidSortFieldError: 'aaaaa' is not a valid sort field "
	    		+ "(please enter 'date', 'name' or 'priority')") );
	    executeTest();
	      
	    input = "1 reset aaaaaaaaaa";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidResetError: 'aaaaaaaaaa' is not a field that can be reset") );
	    executeTest();
	    
	    //Test invalid time
	    input = "4 from 20 Dec 2:60pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidTimeError: '2:60pm' is not an acceptable time format") );
	    executeTest();
	    
	    input = "4 from 20 Dec 12:77";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidTimeError: '12:77' is not an acceptable time format") );
	    executeTest();
	    
	    input = "4 by 20 Dec 3:99am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidTimeError: '3:99am' is not an acceptable time format") );
	    executeTest();
	    
	    input = "4 by 20 Dec 25pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidTimeError: '25pm' is not an acceptable time format") );
	    executeTest();
	    
	    input = "4 by 20 Dec 24pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidTimeError: '24pm' is not an acceptable time format") );
	    executeTest();
	    
	    input = "4 by 20 Dec 36:32";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidTimeError: '36:32' is not an acceptable time format") );
	    executeTest();
	    
	    //Test invalid date
	    input = "5 by 32/3 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidDayOfMonthError: The date '32/3' does not exist (March only has 31 days!)") );
	    executeTest();
	    
	    input = "5 by 32 apr 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidDayOfMonthError: The date '32 apr' does not exist (April only has 30 days!)") );
	    executeTest();
	    
	    input = "5 by may 32 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidDayOfMonthError: The date 'may 32' does not exist (May only has 31 days!)") );
	    executeTest();
	    
	    input = "5 from may 2 10am to 42 jun 4pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidDayOfMonthError: The date '42 jun' does not exist (June only has 30 days!)") );
	    executeTest();
	    
	    input = "5 from may 72 10am to 42 jun 4pm";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidDayOfMonthError: The date 'may 72' does not exist (May only has 31 days!)") );
	    executeTest();
	    
	    input = "5 by 31/4 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidDayOfMonthError: The date '31/4' does not exist (April only has 30 days!)") );
	    executeTest();
	    
	    input = "5 by 31 June 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidDayOfMonthError: The date '31 June' does not exist (June only has 30 days!)") );
	    executeTest();
	    
	    input = "5 by 30 Feb 10am";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "InvalidDayOfMonthError: The date '30 Feb' does not exist (February only has 29 days!)") );
	    executeTest();
	    
	    input = "add floating task every day";
	    actual = parser.parseInput(input);
	    expected = new ArrayList<String>( Arrays.asList("error", "NoDateForRecurrenceError: Cannot make floating task recur. Please set a deadline or start date for the task") );
	    executeTest();
	}
}
```
